"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointResourceType = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_resource_type_1 = require("./xds-resource-type");
const net_1 = require("net");
const resources_1 = require("../resources");
const environment_1 = require("../environment");
const TRACER_NAME = 'xds_client';
const UINT32_MAX = 0xFFFFFFFF;
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
function localitiesEqual(a, b) {
    return a.region === b.region && a.sub_zone === b.sub_zone && a.zone === b.zone;
}
function addressesEqual(a, b) {
    return a.address === b.address && a.port_value === b.port_value;
}
class EndpointResourceType extends xds_resource_type_1.XdsResourceType {
    constructor() {
        super();
    }
    static get() {
        return EndpointResourceType.singleton;
    }
    getTypeUrl() {
        return 'envoy.config.endpoint.v3.ClusterLoadAssignment';
    }
    /**
     *
     * @param socketAddress
     * @param seenAddresses
     * @returns A list of validation errors, if there are any. An empty list indicates success
     */
    validateAddress(socketAddress, seenAddresses) {
        const errors = [];
        if (socketAddress.port_specifier !== 'port_value') {
            errors.push(`Unsupported port_specifier: ${socketAddress.port_specifier}`);
        }
        if (!((0, net_1.isIPv4)(socketAddress.address) || (0, net_1.isIPv6)(socketAddress.address))) {
            errors.push(`address is not a valid IPv4 or IPv6 address: ${socketAddress.address}`);
        }
        for (const address of seenAddresses) {
            if (addressesEqual(socketAddress, address)) {
                errors.push(`address is a duplicate of another address in the same endpoint: ${socketAddress.address}`);
            }
        }
        return errors;
    }
    validateResource(message) {
        const errors = [];
        const seenLocalities = [];
        const seenAddresses = [];
        const priorityTotalWeights = new Map();
        for (const [index, endpoint] of message.endpoints.entries()) {
            const errorPrefix = `endpoints[${index}]`;
            if (!endpoint.locality) {
                errors.push(`${errorPrefix}.locality unset`);
                continue;
            }
            for (const { locality, priority } of seenLocalities) {
                if (localitiesEqual(endpoint.locality, locality) && endpoint.priority === priority) {
                    errors.push(`${errorPrefix}.locality is a duplicate of another locality in the endpoint`);
                }
            }
            seenLocalities.push({ locality: endpoint.locality, priority: endpoint.priority });
            for (const [lbIndex, lb] of endpoint.lb_endpoints.entries()) {
                const lbErrorPrefix = `${errorPrefix}.lb_endpoints[${lbIndex}].endpoint`;
                const socketAddress = lb.endpoint?.address?.socket_address;
                if (socketAddress) {
                    errors.push(...this.validateAddress(socketAddress, seenAddresses).map(error => `${lbErrorPrefix}: ${error}`));
                    seenAddresses.push(socketAddress);
                }
                else {
                    errors.push(`${lbErrorPrefix}.socket_address not set`);
                }
                if (environment_1.EXPERIMENTAL_DUALSTACK_ENDPOINTS && lb.endpoint?.additional_addresses) {
                    for (const [addressIndex, additionalAddress] of lb.endpoint.additional_addresses.entries()) {
                        if (additionalAddress.address?.socket_address) {
                            errors.push(...this.validateAddress(additionalAddress.address.socket_address, seenAddresses).map(error => `${lbErrorPrefix}.additional_addresses[${addressIndex}].address.socket_address: ${error}`));
                            seenAddresses.push(additionalAddress.address.socket_address);
                        }
                        else {
                            errors.push(`${lbErrorPrefix}.additional_addresses[${addressIndex}].address.socket_address unset`);
                        }
                    }
                }
            }
            priorityTotalWeights.set(endpoint.priority, (priorityTotalWeights.get(endpoint.priority) ?? 0) + (endpoint.load_balancing_weight?.value ?? 0));
        }
        for (const [priority, totalWeight] of priorityTotalWeights.entries()) {
            if (totalWeight > UINT32_MAX) {
                errors.push(`priority ${priority} has total weight greater than UINT32_MAX: ${totalWeight}`);
            }
            if (priority > 0 && !priorityTotalWeights.has(priority - 1)) {
                errors.push(`Endpoints have priority ${priority} but not ${priority - 1}`);
            }
        }
        if (errors.length === 0) {
            return {
                valid: true,
                result: message
            };
        }
        else {
            return {
                valid: false,
                errors
            };
        }
    }
    decode(context, resource) {
        if (resource.type_url !== resources_1.EDS_TYPE_URL) {
            throw new Error(`ADS Error: Invalid resource type ${resource.type_url}, expected ${resources_1.EDS_TYPE_URL}`);
        }
        const message = (0, resources_1.decodeSingleResource)(resources_1.EDS_TYPE_URL, resource.value);
        trace('Decoded raw resource of type ' + resources_1.EDS_TYPE_URL + ': ' + JSON.stringify(message, undefined, 2));
        const validationResult = this.validateResource(message);
        if (validationResult.valid) {
            return {
                name: validationResult.result.cluster_name,
                value: validationResult.result
            };
        }
        else {
            return {
                name: message.cluster_name,
                error: `ClusterLoadAssignment message validation failed: [${validationResult.errors}]`
            };
        }
    }
    allResourcesRequiredInSotW() {
        return false;
    }
    static startWatch(client, name, watcher) {
        client.watchResource(EndpointResourceType.get(), name, watcher);
    }
    static cancelWatch(client, name, watcher) {
        client.cancelResourceWatch(EndpointResourceType.get(), name, watcher);
    }
}
exports.EndpointResourceType = EndpointResourceType;
EndpointResourceType.singleton = new EndpointResourceType();
//# sourceMappingURL=endpoint-resource-type.js.map