"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XDS_CLIENT_KEY = exports.XDS_CONFIG_KEY = void 0;
exports.getListenerResourceName = getListenerResourceName;
exports.setup = setup;
const re2_wasm_1 = require("re2-wasm");
const xds_client_1 = require("./xds-client");
const grpc_js_1 = require("@grpc/grpc-js");
var uriToString = grpc_js_1.experimental.uriToString;
var registerResolver = grpc_js_1.experimental.registerResolver;
const route_action_1 = require("./route-action");
const resources_1 = require("./resources");
const http_filter_1 = require("./http-filter");
const environment_1 = require("./environment");
const xds_bootstrap_1 = require("./xds-bootstrap");
const duration_1 = require("./duration");
const xxhash_1 = require("./xxhash");
const xds_bootstrap_2 = require("./xds-bootstrap");
const route_1 = require("./route");
const xds_dependency_manager_1 = require("./xds-dependency-manager");
const TRACER_NAME = 'xds_resolver';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
function protoDurationToSecondsString(duration) {
    return `${duration.seconds + duration.nanos / 1000000000}s`;
}
const DEFAULT_RETRY_BASE_INTERVAL = '0.025s';
function getDefaultRetryMaxInterval(baseInterval) {
    return `${Number.parseFloat(baseInterval.substring(0, baseInterval.length - 1)) * 10}s`;
}
function getListenerResourceName(bootstrapConfig, target) {
    if (target.authority && target.authority !== '') {
        if (target.authority in bootstrapConfig.authorities) {
            return (0, xds_bootstrap_2.formatTemplateString)(bootstrapConfig.authorities[target.authority].clientListenerResourceNameTemplate, target.path);
        }
        else {
            throw new Error(`Authority ${target.authority} not found in bootstrap file`);
        }
    }
    else {
        return (0, xds_bootstrap_2.formatTemplateString)(bootstrapConfig.clientDefaultListenerResourceNameTemplate, target.path);
    }
}
const BOOTSTRAP_CONFIG_KEY = 'grpc.TEST_ONLY_DO_NOT_USE_IN_PROD.xds_bootstrap_config';
const RETRY_CODES = {
    'cancelled': grpc_js_1.status.CANCELLED,
    'deadline-exceeded': grpc_js_1.status.DEADLINE_EXCEEDED,
    'internal': grpc_js_1.status.INTERNAL,
    'resource-exhausted': grpc_js_1.status.RESOURCE_EXHAUSTED,
    'unavailable': grpc_js_1.status.UNAVAILABLE
};
exports.XDS_CONFIG_KEY = `${grpc_js_1.experimental.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX}.xds_config`;
exports.XDS_CLIENT_KEY = 'grpc.internal.xds_client';
/**
 * Tracks a dynamic subscription to a cluster that is currently or previously
 * referenced in a RouteConfiguration.
 */
class ClusterRef {
    constructor(unsubscribe) {
        this.unsubscribe = unsubscribe;
        this.refCount = 0;
    }
    ref() {
        this.refCount += 1;
    }
    unref() {
        this.refCount -= 1;
        if (this.refCount <= 0) {
            this.unsubscribe();
        }
    }
    hasRef() {
        return this.refCount > 0;
    }
}
class XdsResolver {
    constructor(target, listener, channelOptions) {
        this.target = target;
        this.listener = listener;
        this.channelOptions = channelOptions;
        this.listenerResourceName = null;
        this.bootstrapInfo = null;
        this.xdsDependencyManager = null;
        this.clusterRefs = new Map();
        if (channelOptions[BOOTSTRAP_CONFIG_KEY]) {
            const parsedConfig = JSON.parse(channelOptions[BOOTSTRAP_CONFIG_KEY]);
            this.bootstrapInfo = (0, xds_bootstrap_1.validateBootstrapConfig)(parsedConfig);
            this.xdsClient = new xds_client_1.XdsClient(this.bootstrapInfo);
        }
        else {
            this.xdsClient = (0, xds_client_1.getSingletonXdsClient)();
        }
        this.xdsConfigWatcher = {
            onUpdate: xdsConfig => {
                this.handleXdsConfig(xdsConfig);
            },
            onError: (context, status) => {
                trace('Resolution error for target ' + uriToString(this.target) + ' due to xDS client transient error retrieving ' + context + ': ' + status.details);
                this.reportResolutionError(`Error retrieving resource ${context}: ${status.details}`);
            },
            onResourceDoesNotExist: context => {
                trace('Resolution error for target ' + uriToString(this.target) + ': ' + context + ' does not exist');
                /* Return an empty endpoint list and service config, to explicitly
                 * invalidate any previously returned service config */
                this.listener.onSuccessfulResolution([], null, null, null, {});
            }
        };
    }
    pruneUnusedClusters() {
        for (const [cluster, clusterRef] of this.clusterRefs) {
            if (!clusterRef.hasRef()) {
                this.clusterRefs.delete(cluster);
            }
        }
    }
    async handleXdsConfig(xdsConfig) {
        /* We need to load the xxhash API before this function finishes, because
         * it is invoked in the config selector, which can be called immediately
         * after this function returns. */
        await (0, xxhash_1.loadXxhashApi)();
        this.pruneUnusedClusters();
        const httpConnectionManager = (0, resources_1.decodeSingleResource)(resources_1.HTTP_CONNECTION_MANGER_TYPE_URL, xdsConfig.listener.api_listener.api_listener.value);
        const configDefaultTimeout = httpConnectionManager.common_http_protocol_options?.idle_timeout;
        let defaultTimeout = undefined;
        if (configDefaultTimeout === null || configDefaultTimeout === undefined) {
            defaultTimeout = undefined;
        }
        else {
            defaultTimeout = (0, duration_1.protoDurationToDuration)(configDefaultTimeout);
        }
        const ldsHttpFilterConfigs = [];
        if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
            for (const filter of httpConnectionManager.http_filters) {
                // typed_config must be set here, or validation would have failed
                const filterConfig = (0, http_filter_1.parseTopLevelFilterConfig)(filter.typed_config);
                if (filterConfig) {
                    ldsHttpFilterConfigs.push({ name: filter.name, config: filterConfig });
                }
            }
        }
        const virtualHost = xdsConfig.virtualHost;
        const virtualHostHttpFilterOverrides = new Map();
        if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
            for (const [name, filter] of Object.entries(virtualHost.typed_per_filter_config ?? {})) {
                const parsedConfig = (0, http_filter_1.parseOverrideFilterConfig)(filter);
                if (parsedConfig) {
                    virtualHostHttpFilterOverrides.set(name, parsedConfig);
                }
            }
        }
        trace('Received virtual host config ' + JSON.stringify(virtualHost, undefined, 2));
        const allConfigClusters = new Set();
        const matchList = [];
        for (const route of virtualHost.routes) {
            let routeAction;
            let timeout;
            /* For field prioritization see
             * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#supported-fields
             */
            if (route.route?.max_stream_duration?.grpc_timeout_header_max) {
                timeout = (0, duration_1.protoDurationToDuration)(route.route.max_stream_duration.grpc_timeout_header_max);
            }
            else if (route.route?.max_stream_duration?.max_stream_duration) {
                timeout = (0, duration_1.protoDurationToDuration)(route.route.max_stream_duration.max_stream_duration);
            }
            else {
                timeout = defaultTimeout;
            }
            // "A value of 0 indicates the application's deadline is used without modification."
            if (timeout?.seconds === 0 && timeout.nanos === 0) {
                timeout = undefined;
            }
            const routeHttpFilterOverrides = new Map();
            if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
                for (const [name, filter] of Object.entries(route.typed_per_filter_config ?? {})) {
                    const parsedConfig = (0, http_filter_1.parseOverrideFilterConfig)(filter);
                    if (parsedConfig) {
                        routeHttpFilterOverrides.set(name, parsedConfig);
                    }
                }
            }
            let retryPolicy = undefined;
            if (environment_1.EXPERIMENTAL_RETRY) {
                const retryConfig = route.route.retry_policy ?? virtualHost.retry_policy;
                if (retryConfig) {
                    const retryableStatusCodes = [];
                    for (const code of retryConfig.retry_on.split(',')) {
                        if (RETRY_CODES[code]) {
                            retryableStatusCodes.push(RETRY_CODES[code]);
                        }
                    }
                    if (retryableStatusCodes.length > 0) {
                        const baseInterval = retryConfig.retry_back_off?.base_interval ?
                            protoDurationToSecondsString(retryConfig.retry_back_off.base_interval) :
                            DEFAULT_RETRY_BASE_INTERVAL;
                        const maxInterval = retryConfig.retry_back_off?.max_interval ?
                            protoDurationToSecondsString(retryConfig.retry_back_off.max_interval) :
                            getDefaultRetryMaxInterval(baseInterval);
                        retryPolicy = {
                            backoffMultiplier: 2,
                            initialBackoff: baseInterval,
                            maxBackoff: maxInterval,
                            maxAttempts: (retryConfig.num_retries?.value ?? 1) + 1,
                            retryableStatusCodes: retryableStatusCodes
                        };
                    }
                }
            }
            const hashPolicies = [];
            if (environment_1.EXPERIMENTAL_RING_HASH) {
                for (const routeHashPolicy of route.route.hash_policy) {
                    if (routeHashPolicy.policy_specifier === 'header') {
                        const headerPolicy = routeHashPolicy.header;
                        hashPolicies.push({
                            type: 'HEADER',
                            terminal: routeHashPolicy.terminal,
                            headerName: headerPolicy.header_name,
                            regex: headerPolicy.regex_rewrite?.pattern ? new re2_wasm_1.RE2(headerPolicy.regex_rewrite.pattern.regex, 'ug') : undefined,
                            regexSubstitution: headerPolicy.regex_rewrite?.substitution
                        });
                    }
                    else if (routeHashPolicy.policy_specifier === 'filter_state' && routeHashPolicy.filter_state.key === 'io.grpc.channel_id') {
                        hashPolicies.push({
                            type: 'CHANNEL_ID',
                            terminal: routeHashPolicy.terminal
                        });
                    }
                }
            }
            switch (route.route.cluster_specifier) {
                case 'cluster_header':
                    continue;
                case 'cluster': {
                    const cluster = route.route.cluster;
                    allConfigClusters.add(cluster);
                    const extraFilterFactories = [];
                    if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
                        for (const filterConfig of ldsHttpFilterConfigs) {
                            if (routeHttpFilterOverrides.has(filterConfig.name)) {
                                const filter = (0, http_filter_1.createHttpFilter)(filterConfig.config, routeHttpFilterOverrides.get(filterConfig.name));
                                if (filter) {
                                    extraFilterFactories.push(filter);
                                }
                            }
                            else if (virtualHostHttpFilterOverrides.has(filterConfig.name)) {
                                const filter = (0, http_filter_1.createHttpFilter)(filterConfig.config, virtualHostHttpFilterOverrides.get(filterConfig.name));
                                if (filter) {
                                    extraFilterFactories.push(filter);
                                }
                            }
                            else {
                                const filter = (0, http_filter_1.createHttpFilter)(filterConfig.config);
                                if (filter) {
                                    extraFilterFactories.push(filter);
                                }
                            }
                        }
                    }
                    routeAction = new route_action_1.SingleClusterRouteAction(cluster, { name: [], timeout: timeout, retryPolicy: retryPolicy }, extraFilterFactories, hashPolicies);
                    break;
                }
                case 'weighted_clusters': {
                    const weightedClusters = [];
                    for (const clusterWeight of route.route.weighted_clusters.clusters) {
                        allConfigClusters.add(clusterWeight.name);
                        const extraFilterFactories = [];
                        const clusterHttpFilterOverrides = new Map();
                        if (environment_1.EXPERIMENTAL_FAULT_INJECTION) {
                            for (const [name, filter] of Object.entries(clusterWeight.typed_per_filter_config ?? {})) {
                                const parsedConfig = (0, http_filter_1.parseOverrideFilterConfig)(filter);
                                if (parsedConfig) {
                                    clusterHttpFilterOverrides.set(name, parsedConfig);
                                }
                            }
                            for (const filterConfig of ldsHttpFilterConfigs) {
                                if (clusterHttpFilterOverrides.has(filterConfig.name)) {
                                    const filter = (0, http_filter_1.createHttpFilter)(filterConfig.config, clusterHttpFilterOverrides.get(filterConfig.name));
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                                else if (routeHttpFilterOverrides.has(filterConfig.name)) {
                                    const filter = (0, http_filter_1.createHttpFilter)(filterConfig.config, routeHttpFilterOverrides.get(filterConfig.name));
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                                else if (virtualHostHttpFilterOverrides.has(filterConfig.name)) {
                                    const filter = (0, http_filter_1.createHttpFilter)(filterConfig.config, virtualHostHttpFilterOverrides.get(filterConfig.name));
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                                else {
                                    const filter = (0, http_filter_1.createHttpFilter)(filterConfig.config);
                                    if (filter) {
                                        extraFilterFactories.push(filter);
                                    }
                                }
                            }
                        }
                        weightedClusters.push({ name: clusterWeight.name, weight: clusterWeight.weight?.value ?? 0, dynamicFilterFactories: extraFilterFactories });
                    }
                    routeAction = new route_action_1.WeightedClusterRouteAction(weightedClusters, route.route.weighted_clusters.total_weight?.value ?? 100, { name: [], timeout: timeout, retryPolicy: retryPolicy }, hashPolicies);
                    break;
                }
                default:
                    /* The validation logic should prevent us from reaching this point.
                     * This is just for the type checker. */
                    continue;
            }
            const routeMatcher = (0, route_1.getPredicateForMatcher)(route.match);
            matchList.push({ matcher: routeMatcher, action: routeAction });
        }
        for (const cluster of allConfigClusters) {
            let clusterRef = this.clusterRefs.get(cluster);
            if (!clusterRef) {
                clusterRef = new ClusterRef(this.xdsDependencyManager.addClusterSubscription(cluster));
                this.clusterRefs.set(cluster, clusterRef);
            }
            clusterRef.ref();
        }
        const configSelector = {
            invoke: (methodName, metadata, channelId) => {
                for (const { matcher, action } of matchList) {
                    if (matcher.apply(methodName, metadata)) {
                        const clusterResult = action.getCluster();
                        const clusterRef = this.clusterRefs.get(clusterResult.name);
                        clusterRef.ref();
                        const onCommitted = () => {
                            clusterRef.unref();
                        };
                        let hash;
                        if (environment_1.EXPERIMENTAL_RING_HASH) {
                            hash = `${action.getHash(metadata, channelId)}`;
                        }
                        else {
                            hash = '';
                        }
                        return {
                            methodConfig: clusterResult.methodConfig,
                            onCommitted: onCommitted,
                            pickInformation: { cluster: clusterResult.name, hash: hash },
                            status: grpc_js_1.status.OK,
                            dynamicFilterFactories: clusterResult.dynamicFilterFactories
                        };
                    }
                }
                return {
                    methodConfig: { name: [] },
                    // These fields won't be used here, but they're set because of some TypeScript weirdness
                    pickInformation: { cluster: '', hash: '' },
                    status: grpc_js_1.status.UNAVAILABLE,
                    dynamicFilterFactories: []
                };
            },
            unref: () => {
                for (const cluster of allConfigClusters) {
                    this.clusterRefs.get(cluster)?.unref();
                }
            }
        };
        trace('Created ConfigSelector with configuration:');
        for (const { matcher, action } of matchList) {
            trace(matcher.toString());
            trace('=> ' + action.toString());
        }
        const clusterConfigMap = {};
        for (const clusterName of this.clusterRefs.keys()) {
            clusterConfigMap[clusterName] = { child_policy: [{ cds: { cluster: clusterName } }] };
        }
        const lbPolicyConfig = { xds_cluster_manager: { children: clusterConfigMap } };
        const serviceConfig = {
            methodConfig: [],
            loadBalancingConfig: [lbPolicyConfig]
        };
        this.listener.onSuccessfulResolution([], serviceConfig, null, configSelector, {
            [exports.XDS_CLIENT_KEY]: this.xdsClient,
            [exports.XDS_CONFIG_KEY]: xdsConfig
        });
    }
    reportResolutionError(reason) {
        this.listener.onError({
            code: grpc_js_1.status.UNAVAILABLE,
            details: `xDS name resolution failed for target ${uriToString(this.target)}: ${reason}`,
            metadata: new grpc_js_1.Metadata(),
        });
    }
    startResolution() {
        if (!this.xdsDependencyManager) {
            trace('Starting resolution for target ' + uriToString(this.target));
            try {
                const listenerResourceName = getListenerResourceName(this.bootstrapInfo, this.target);
                trace('Resolving target ' + uriToString(this.target) + ' with Listener resource name ' + this.listenerResourceName);
                const hostDomain = this.channelOptions['grpc.default_authority'] ?? this.target.path;
                this.xdsDependencyManager = new xds_dependency_manager_1.XdsDependencyManager(this.xdsClient, listenerResourceName, hostDomain, this.xdsConfigWatcher);
            }
            catch (e) {
                this.reportResolutionError(e.message);
                return;
            }
        }
        this.xdsDependencyManager.updateResolution();
    }
    updateResolution() {
        if (environment_1.EXPERIMENTAL_FEDERATION) {
            if (this.bootstrapInfo) {
                this.startResolution();
            }
            else {
                try {
                    this.bootstrapInfo = (0, xds_bootstrap_1.loadBootstrapInfo)();
                }
                catch (e) {
                    this.reportResolutionError(e.message);
                }
                this.startResolution();
            }
        }
        else {
            if (!this.xdsDependencyManager) {
                trace('Starting resolution for target ' + uriToString(this.target));
                const hostDomain = this.channelOptions['grpc.default_authority'] ?? this.target.path;
                this.xdsDependencyManager = new xds_dependency_manager_1.XdsDependencyManager(this.xdsClient, this.target.path, hostDomain, this.xdsConfigWatcher);
            }
            this.xdsDependencyManager.updateResolution();
        }
    }
    destroy() {
        if (this.xdsDependencyManager) {
            this.xdsDependencyManager.destroy();
            this.xdsDependencyManager = null;
        }
    }
    static getDefaultAuthority(target) {
        return target.path;
    }
}
function setup() {
    registerResolver('xds', XdsResolver);
}
//# sourceMappingURL=resolver-xds.js.map