"use strict";
/*
* Copyright 2024 gRPC authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.XdsServer = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const xds_bootstrap_1 = require("./xds-bootstrap");
const net = require("net");
var splitHostPort = grpc_js_1.experimental.splitHostPort;
var createServerCredentialsWithInterceptors = grpc_js_1.experimental.createServerCredentialsWithInterceptors;
const xds_client_1 = require("./xds-client");
const route_config_resource_type_1 = require("./xds-resource-type/route-config-resource-type");
const listener_resource_type_1 = require("./xds-resource-type/listener-resource-type");
const cidr_1 = require("./cidr");
const server_listener_1 = require("./server-listener");
const resources_1 = require("./resources");
const route_1 = require("./route");
const cross_product_1 = require("./cross-product");
const xds_dependency_manager_1 = require("./xds-dependency-manager");
const xds_credentials_1 = require("./xds-credentials");
const TRACER_NAME = 'xds_server';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
/**
 * Validates that a listening address to be bound is valid for use in the xDS
 * server: It must be in the form IP:port, and port must be non-zero.
 * @param listeningAddress
 * @returns
 */
function isValidIpPort(hostPort) {
    return hostPort !== null && (net.isIPv4(hostPort.host) || net.isIPv6(hostPort.host)) && hostPort.port !== undefined && hostPort.port > 0;
}
const routeErrorStatus = {
    code: grpc_js_1.status.UNAVAILABLE,
    details: 'Routing error'
};
class FilterChainEntry {
    constructor(configParameters, filterChain, credentials, onRouteConfigPopulated) {
        this.configParameters = configParameters;
        this.rdsName = null;
        this.rdsError = null;
        this.virtualHosts = null;
        this.hasRouteConfigErrors = false;
        this.matchers = normalizeFilterChainMatch(filterChain.filter_chain_match);
        const httpConnectionManager = (0, resources_1.decodeSingleResource)(resources_1.HTTP_CONNECTION_MANGER_TYPE_URL, filterChain.filters[0].typed_config.value);
        trace('Populating FilterChainEntry from HttpConncectionManager ' + JSON.stringify(httpConnectionManager, undefined, 2));
        this.routeConfigWatcher = new xds_client_1.Watcher({
            onResourceChanged: (resource) => {
                if (this.rdsError) {
                    grpc_js_1.experimental.log(grpc_js_1.logVerbosity.ERROR, 'Retrieved previously missing RouteConfiguration resource ' + this.rdsName);
                }
                this.rdsError = null;
                this.handleRouteConfigurationResource(resource);
                onRouteConfigPopulated();
            },
            onResourceDoesNotExist: () => {
                this.virtualHosts = null;
                this.rdsError = `Resource does not exist`;
                this.logConfigurationError(this.rdsError);
                onRouteConfigPopulated();
            },
            onError: (status) => {
                if (!this.virtualHosts) {
                    this.rdsError = `Error retrieving resource: ${status.details}`;
                    this.logConfigurationError(this.rdsError);
                }
                onRouteConfigPopulated();
            }
        });
        if (httpConnectionManager.route_config) {
            this.handleRouteConfigurationResource(httpConnectionManager.route_config);
            process.nextTick(onRouteConfigPopulated);
        }
        else if (httpConnectionManager.rds) {
            this.rdsName = httpConnectionManager.rds.route_config_name;
            route_config_resource_type_1.RouteConfigurationResourceType.startWatch(this.configParameters.xdsClient, this.rdsName, this.routeConfigWatcher);
        }
        const interceptor = (methodDescriptor, call) => {
            return new grpc_js_1.ServerInterceptingCall(call, {
                start: (next) => {
                    next({
                        onReceiveMetadata: (metadata, next) => {
                            if (!this.virtualHosts) {
                                call.sendStatus(routeErrorStatus);
                                return;
                            }
                            const virtualHost = (0, xds_dependency_manager_1.findVirtualHostForDomain)(this.virtualHosts, call.getHost());
                            if (!virtualHost) {
                                call.sendStatus(routeErrorStatus);
                                return;
                            }
                            for (const route of virtualHost.routes) {
                                if (route.matcher.apply(methodDescriptor.path, metadata)) {
                                    if (route.isNonForwardingAction) {
                                        next(metadata);
                                    }
                                    else {
                                        call.sendStatus(routeErrorStatus);
                                    }
                                    return;
                                }
                            }
                            call.sendStatus(routeErrorStatus);
                        }
                    });
                }
            });
        };
        if (credentials instanceof xds_credentials_1.XdsServerCredentials) {
            if (filterChain.transport_socket) {
                trace('Using secure credentials');
                const downstreamTlsContext = (0, resources_1.decodeSingleResource)(resources_1.DOWNSTREAM_TLS_CONTEXT_TYPE_URL, filterChain.transport_socket.typed_config.value);
                const commonTlsContext = downstreamTlsContext.common_tls_context;
                const instanceCertificateProvider = configParameters.xdsClient.getCertificateProvider(commonTlsContext.tls_certificate_provider_instance.instance_name);
                if (!instanceCertificateProvider) {
                    throw new Error(`Invalid TLS context detected: unrecognized certificate instance name: ${commonTlsContext.tls_certificate_provider_instance.instance_name}`);
                }
                let validationContext = null;
                if (commonTlsContext?.validation_context_type) {
                    switch (commonTlsContext?.validation_context_type) {
                        case 'validation_context':
                            validationContext = commonTlsContext.validation_context;
                            break;
                        case 'combined_validation_context':
                            validationContext = commonTlsContext.combined_validation_context.default_validation_context;
                            break;
                        default:
                            throw new Error(`Invalid TLS context detected: invalid validation_context_type: ${commonTlsContext.validation_context_type}`);
                    }
                }
                let caCertificateProvider = null;
                if (validationContext?.ca_certificate_provider_instance) {
                    caCertificateProvider = configParameters.xdsClient.getCertificateProvider(validationContext.ca_certificate_provider_instance.instance_name) ?? null;
                    if (!caCertificateProvider) {
                        throw new Error(`Invalid TLS context detected: unrecognized certificate instance name: ${validationContext.ca_certificate_provider_instance.instance_name}`);
                    }
                }
                credentials = grpc_js_1.experimental.createCertificateProviderServerCredentials(instanceCertificateProvider, caCertificateProvider, downstreamTlsContext.require_client_certificate?.value ?? false);
            }
            else {
                trace('Using fallback credentials');
                credentials = credentials.getFallbackCredentials();
            }
        }
        const interceptingCredentials = createServerCredentialsWithInterceptors(credentials, [interceptor]);
        this.connectionInjector = configParameters.createConnectionInjector(interceptingCredentials);
    }
    handleRouteConfigurationResource(routeConfig) {
        let hasRouteConfigErrors = false;
        this.virtualHosts = [];
        for (const virtualHost of routeConfig.virtual_hosts) {
            const virtualHostEntry = {
                domains: virtualHost.domains,
                routes: []
            };
            for (const route of virtualHost.routes) {
                const routeEntry = {
                    matcher: (0, route_1.getPredicateForMatcher)(route.match),
                    isNonForwardingAction: route.action === 'non_forwarding_action'
                };
                if (!routeEntry.isNonForwardingAction) {
                    hasRouteConfigErrors = true;
                    this.logConfigurationError('For domains matching [' + virtualHostEntry.domains + '] requests will be rejected for routes matching ' + routeEntry.matcher.toString());
                }
                virtualHostEntry.routes.push(routeEntry);
            }
            this.virtualHosts.push(virtualHostEntry);
        }
        if (this.hasRouteConfigErrors && !hasRouteConfigErrors) {
            grpc_js_1.experimental.log(grpc_js_1.logVerbosity.ERROR, 'Routes will no longer reject requests for RouteConfiguration ' + this.rdsName);
        }
        this.hasRouteConfigErrors = hasRouteConfigErrors;
    }
    logConfigurationError(text) {
        grpc_js_1.experimental.log(grpc_js_1.logVerbosity.ERROR, 'RouteConfiguration error (' + this.rdsName + '): ' + text);
    }
    getMatchers() {
        return this.matchers;
    }
    isPopulated() {
        return !!(this.virtualHosts || this.rdsError);
    }
    handleConnection(socket) {
        this.connectionInjector.injectConnection(socket);
    }
    shutdown() {
        this.connectionInjector.drain(this.configParameters.drainGraceTimeMs);
        this.connectionInjector.destroy();
        if (this.rdsName) {
            route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.configParameters.xdsClient, this.rdsName, this.routeConfigWatcher);
        }
    }
    drain(graceTimeMs) {
        this.connectionInjector.drain(graceTimeMs);
    }
}
class ListenerConfig {
    constructor(configParameters, resource, credentials, onReadyToUse) {
        this.configParameters = configParameters;
        this.resource = resource;
        this.onReadyToUse = onReadyToUse;
        this.defaultFilterChain = null;
        this.reportedReadyToUse = false;
        trace('Populating ListenerConfig from listener ' + resource.name);
        this.filterChainEntries = [];
        for (const filterChain of resource.filter_chains) {
            this.filterChainEntries.push(new FilterChainEntry(configParameters, filterChain, credentials, () => this.maybeReportReadyToUse()));
        }
        if (resource.default_filter_chain) {
            this.defaultFilterChain = new FilterChainEntry(configParameters, resource.default_filter_chain, credentials, () => this.maybeReportReadyToUse());
        }
    }
    maybeReportReadyToUse() {
        if (this.reportedReadyToUse) {
            return;
        }
        for (const entry of this.filterChainEntries) {
            if (!entry.isPopulated()) {
                return;
            }
        }
        if (this.defaultFilterChain && !this.defaultFilterChain.isPopulated()) {
            return;
        }
        this.reportedReadyToUse = true;
        this.onReadyToUse();
    }
    isEquivalentResource(listener) {
        return (0, server_listener_1.listenersEquivalent)(listener, this.resource);
    }
    handleConnection(socket) {
        const matchingFilter = selectMostSpecificallyMatchingFilter(this.filterChainEntries, socket) ?? this.defaultFilterChain;
        if (!matchingFilter) {
            trace('Rejecting connection from ' + socket.remoteAddress + ': No filter matched');
            socket.destroy();
            return;
        }
        matchingFilter.handleConnection(socket);
    }
    shutdown() {
        for (const entry of this.filterChainEntries) {
            entry.shutdown();
        }
        this.defaultFilterChain?.shutdown();
    }
    drain(graceTimeMs) {
        this.filterChainEntries.forEach(entry => entry.drain(graceTimeMs));
        this.defaultFilterChain?.drain(graceTimeMs);
    }
}
class BoundPortEntry {
    constructor(configParameters, boundAddress, credentials) {
        this.configParameters = configParameters;
        this.boundAddress = boundAddress;
        this.credentials = credentials;
        this.currentConfig = null;
        this.pendingConfig = null;
        this.servingStatusListeners = new Set();
        this.listenerWatcher = new xds_client_1.Watcher({
            onResourceChanged: (resource) => {
                trace('Received listener resource ' + resource.name);
                this.handleListenerResource(resource);
            },
            onResourceDoesNotExist: () => {
                this.currentConfig?.shutdown();
                this.currentConfig = null;
                this.pendingConfig?.shutdown();
                this.pendingConfig = null;
            },
            onError: (status) => {
                if (!this.currentConfig && !this.pendingConfig) {
                    this.updateServingStatus(status);
                }
            }
        });
        this.tcpServer = new net.Server(socket => {
            if (this.currentConfig && this.servingStatus.code === grpc_js_1.status.OK) {
                this.currentConfig.handleConnection(socket);
            }
            else {
                socket.destroy();
            }
        });
        this.servingStatus = {
            code: grpc_js_1.status.UNAVAILABLE,
            details: 'Not yet serving',
            metadata: new grpc_js_1.Metadata()
        };
        const resourceName = (0, xds_bootstrap_1.formatTemplateString)(configParameters.listenerResourceNameTemplate, boundAddress);
        trace('Watching for listener resource ' + resourceName);
        listener_resource_type_1.ListenerResourceType.startWatch(configParameters.xdsClient, resourceName, this.listenerWatcher);
    }
    updateServingStatus(status) {
        this.servingStatus = status;
        this.servingStatusListeners.forEach(listener => listener(status));
    }
    handleListenerResource(listener) {
        trace('handleListenerResource(' + listener.name + ')');
        if (!listener.address?.socket_address) {
            const errorText = `No socket_address set in Listener resource for port ${this.boundAddress}`;
            trace('Error handling listener resource: ' + errorText);
            this.updateServingStatus({
                code: grpc_js_1.status.UNAVAILABLE,
                details: errorText,
                metadata: new grpc_js_1.Metadata()
            });
            return;
        }
        const listeningAddress = splitHostPort(this.boundAddress);
        if (!listeningAddress) {
            const errorText = `Could not parse bound address ${this.boundAddress}`;
            trace('Error handling listener resource: ' + errorText);
            this.updateServingStatus({
                code: grpc_js_1.status.UNAVAILABLE,
                details: errorText,
                metadata: new grpc_js_1.Metadata()
            });
            return;
        }
        if (!(listener.address.socket_address.address === listeningAddress.host && listener.address.socket_address.port_value === listeningAddress.port)) {
            const errorText = `socket_address mismatch for port ${this.boundAddress}: got '${listener.address.socket_address.address}:${listener.address.socket_address.port_value}'`;
            trace('Error handling listener resource: ' + errorText);
            this.updateServingStatus({
                code: grpc_js_1.status.UNAVAILABLE,
                details: errorText,
                metadata: new grpc_js_1.Metadata()
            });
            return;
        }
        if (this.currentConfig?.isEquivalentResource(listener)) {
            trace('Listener resource equivalent to current resource');
            this.pendingConfig?.shutdown();
            this.pendingConfig = null;
            return;
        }
        if (this.pendingConfig?.isEquivalentResource(listener)) {
            trace('Listener resource equivalent to pending resource');
            return;
        }
        this.pendingConfig?.shutdown();
        this.pendingConfig = new ListenerConfig(this.configParameters, listener, this.credentials, () => this.startUsingPendingConfig());
    }
    maybeStartServing() {
        if (this.currentConfig && this.tcpServer.listening) {
            this.updateServingStatus({
                code: grpc_js_1.status.OK,
                details: '',
                metadata: new grpc_js_1.Metadata()
            });
        }
    }
    startUsingPendingConfig() {
        this.currentConfig?.shutdown();
        this.currentConfig = this.pendingConfig;
        this.pendingConfig = null;
        if (!this.tcpServer.listening) {
            const listeningAddress = splitHostPort(this.boundAddress);
            if (listeningAddress) {
                this.tcpServer.listen(listeningAddress?.port, () => {
                    this.maybeStartServing();
                });
            }
        }
        this.maybeStartServing();
    }
    addServingStatusListener(listener) {
        this.servingStatusListeners.add(listener);
    }
    removeServingStatusListener(listener) {
        this.servingStatusListeners.delete(listener);
    }
    drain(graceTimeMs) {
        this.currentConfig?.drain(graceTimeMs);
    }
    unbind() {
        this.currentConfig?.shutdown();
        this.pendingConfig?.shutdown();
        this.tcpServer.close();
        const resourceName = (0, xds_bootstrap_1.formatTemplateString)(this.configParameters.listenerResourceNameTemplate, this.boundAddress);
        listener_resource_type_1.ListenerResourceType.cancelWatch(this.configParameters.xdsClient, resourceName, this.listenerWatcher);
        this.configParameters.unregisterChannelzRef();
    }
}
function normalizeFilterChainMatch(filterChainMatch) {
    if (!filterChainMatch) {
        filterChainMatch = {
            address_suffix: '',
            application_protocols: [],
            destination_port: null,
            direct_source_prefix_ranges: [],
            prefix_ranges: [],
            server_names: [],
            source_ports: [],
            source_prefix_ranges: [],
            source_type: 'ANY',
            suffix_len: null,
            transport_protocol: 'raw_buffer'
        };
    }
    if (filterChainMatch.destination_port) {
        return [];
    }
    if (filterChainMatch.server_names.length > 0) {
        return [];
    }
    if (filterChainMatch.transport_protocol !== 'raw_buffer') {
        return [];
    }
    if (filterChainMatch.application_protocols.length > 0) {
        return [];
    }
    const normalizedPrefixRanges = filterChainMatch.prefix_ranges.map(cidr_1.cidrRangeMessageToCidrRange).map(cidr_1.normalizeCidrRange);
    const normalizedSourcePrefixRanges = filterChainMatch.source_prefix_ranges.map(cidr_1.cidrRangeMessageToCidrRange).map(cidr_1.normalizeCidrRange);
    const fieldCrossProduct = (0, cross_product_1.crossProduct)([normalizedPrefixRanges, normalizedSourcePrefixRanges, filterChainMatch.source_ports]);
    return fieldCrossProduct.map(([prefixRange, sourcePrefixRange, sourcePort]) => ({ prefixRange, sourceType: filterChainMatch.source_type, sourcePrefixRange, sourcePort }));
}
function isSameIpOrLoopback(remoteAddress, localAddress) {
    return remoteAddress === '127.0.0.1' || remoteAddress === '::1' || remoteAddress === localAddress;
}
function cidrRangeMatch(range, address) {
    return !range || (!!address && (0, cidr_1.inCidrRange)(range, address));
}
function cidrRangeMoreSpecific(range1, range2) {
    if (!range2) {
        return !!range1;
    }
    return !!range1 && range1.prefixLen > range2.prefixLen;
}
function sourceTypeMatch(sourceType, addresses) {
    switch (sourceType) {
        case "ANY":
            return true;
        case "SAME_IP_OR_LOOPBACK":
            return !!addresses.localAddress && !!addresses.remoteAddress && isSameIpOrLoopback(addresses.remoteAddress, addresses.localAddress);
        case "EXTERNAL":
            return !!addresses.localAddress && !!addresses.remoteAddress && !isSameIpOrLoopback(addresses.remoteAddress, addresses.localAddress);
    }
}
const cidrRangeEvaluator = {
    isMatch: cidrRangeMatch,
    matcherEqual: cidr_1.cidrRangeEqual,
    isMoreSpecific: cidrRangeMoreSpecific
};
const sourceTypeEvaluator = {
    isMatch: sourceTypeMatch,
    matcherEqual: (matcher1, matcher2) => matcher1 === matcher2,
    isMoreSpecific: (matcher1, matcher2) => matcher1 !== 'ANY' && matcher2 === 'ANY'
};
const portEvaluator = {
    isMatch: (matcher, actual) => matcher === undefined || matcher === actual,
    matcherEqual: (matcher1, matcher2) => matcher1 === matcher2,
    isMoreSpecific: (matcher1, matcher2) => matcher1 !== undefined && matcher2 === undefined
};
function selectMostSpecificMatcherForField(fieldName, evaluator, matchers, fieldValue) {
    let filteredCandidates = [];
    for (const candidate of matchers) {
        const fieldMatcher = candidate[fieldName];
        if (!evaluator.isMatch(fieldMatcher, fieldValue)) {
            continue;
        }
        if (filteredCandidates.length === 0) {
            filteredCandidates.push(candidate);
        }
        else if (evaluator.matcherEqual(fieldMatcher, filteredCandidates[0][fieldName])) {
            filteredCandidates.push(candidate);
        }
        else if (evaluator.isMoreSpecific(fieldMatcher, filteredCandidates[0][fieldName])) {
            filteredCandidates = [candidate];
        }
    }
    return filteredCandidates;
}
function selectMostSpecificallyMatchingFilter(filterChains, socket) {
    let matcherMap = new Map(filterChains.map(chain => chain.getMatchers().map(matcher => [matcher, chain])).flat());
    let matcherCandidates = Array.from(matcherMap.keys());
    matcherCandidates = selectMostSpecificMatcherForField('prefixRange', cidrRangeEvaluator, matcherCandidates, socket.localAddress);
    matcherCandidates = selectMostSpecificMatcherForField('sourceType', sourceTypeEvaluator, matcherCandidates, socket);
    matcherCandidates = selectMostSpecificMatcherForField('sourcePrefixRange', cidrRangeEvaluator, matcherCandidates, socket.remoteAddress);
    matcherCandidates = selectMostSpecificMatcherForField('sourcePort', portEvaluator, matcherCandidates, socket.remotePort);
    if (matcherCandidates.length === 1) {
        return matcherMap.get(matcherCandidates[0]);
    }
    else if (matcherCandidates.length === 0) {
        return null;
    }
    else {
        throw new Error('Duplicate matcher found for incoming connection');
    }
}
const BOOTSTRAP_CONFIG_KEY = 'grpc.TEST_ONLY_DO_NOT_USE_IN_PROD.xds_bootstrap_config';
// Default drain grace time of 10 minutes
const DEFAULT_DRAIN_GRACE_TIME_MS = 10 * 60 * 1000;
class XdsServer extends grpc_js_1.Server {
    constructor(options) {
        super(options);
        this.boundPortMap = new Map();
        let bootstrapConfig;
        if (options?.[BOOTSTRAP_CONFIG_KEY]) {
            const parsedConfig = JSON.parse(options[BOOTSTRAP_CONFIG_KEY]);
            bootstrapConfig = (0, xds_bootstrap_1.validateBootstrapConfig)(parsedConfig);
            this.xdsClient = new xds_client_1.XdsClient(bootstrapConfig);
        }
        else {
            bootstrapConfig = (0, xds_bootstrap_1.loadBootstrapInfo)();
            this.xdsClient = (0, xds_client_1.getSingletonXdsClient)();
        }
        if (!bootstrapConfig.serverListenerResourceNameTemplate) {
            throw new Error('Bootstrap file missing required field server_listener_resource_name_template');
        }
        this.listenerResourceNameTemplate = bootstrapConfig.serverListenerResourceNameTemplate;
        this.drainGraceTimeMs = options?.drainGraceTimeMs ?? DEFAULT_DRAIN_GRACE_TIME_MS;
    }
    /**
     * Bind a port using configuration retrieved from the xDS control plane.
     * @param port Port to bind in the format [IP address]:[port number] (e.g. 0.0.0.0:443)
     * @param creds Server credentials object to bind
     * @param callback
     */
    bindAsync(port, creds, callback) {
        // Validate port string has the form IP:port
        const hostPort = splitHostPort(port);
        if (!hostPort || !isValidIpPort(hostPort)) {
            throw new Error(`Listening port string must have the format IP:port with non-zero port, got ${port}`);
        }
        const channelzRef = this.experimentalRegisterListenerToChannelz({ host: hostPort.host, port: hostPort.port });
        const configParameters = {
            createConnectionInjector: (credentials) => this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef),
            drainGraceTimeMs: this.drainGraceTimeMs,
            listenerResourceNameTemplate: this.listenerResourceNameTemplate,
            xdsClient: this.xdsClient,
            unregisterChannelzRef: () => this.experimentalUnregisterListenerFromChannelz(channelzRef)
        };
        const portEntry = new BoundPortEntry(configParameters, port, creds);
        const servingStatusListener = statusObject => {
            if (statusObject.code === grpc_js_1.status.OK) {
                callback(null, hostPort.port);
                portEntry.removeServingStatusListener(servingStatusListener);
            }
        };
        portEntry.addServingStatusListener(servingStatusListener);
        this.boundPortMap.set(port, portEntry);
    }
    drain(port, graceTimeMs) {
        const boundPort = this.boundPortMap.get(port);
        boundPort?.drain(graceTimeMs);
    }
    unbind(port) {
        const boundPort = this.boundPortMap.get(port);
        if (!boundPort) {
            return;
        }
        boundPort.unbind();
        this.boundPortMap.delete(port);
    }
    tryShutdown(callback) {
        for (const portEntry of this.boundPortMap.values()) {
            portEntry.unbind();
        }
        this.boundPortMap.clear();
        super.tryShutdown(callback);
    }
    forceShutdown() {
        for (const portEntry of this.boundPortMap.values()) {
            portEntry.unbind();
        }
        this.boundPortMap.clear();
        super.forceShutdown();
    }
    addServingStateListener(port, listener) {
        const portEntry = this.boundPortMap.get(port);
        if (portEntry) {
            portEntry.addServingStatusListener(listener);
        }
    }
    removeServingStateListener(port, listener) {
        const portEntry = this.boundPortMap.get(port);
        if (portEntry) {
            portEntry.removeServingStatusListener(listener);
        }
    }
}
exports.XdsServer = XdsServer;
//# sourceMappingURL=server.js.map