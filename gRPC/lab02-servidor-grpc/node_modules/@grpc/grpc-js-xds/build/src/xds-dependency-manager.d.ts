import { experimental, StatusObject } from "@grpc/grpc-js";
import { Listener__Output } from "./generated/envoy/config/listener/v3/Listener";
import { RouteConfiguration__Output } from "./generated/envoy/config/route/v3/RouteConfiguration";
import { VirtualHost__Output } from "./generated/envoy/config/route/v3/VirtualHost";
import { CdsUpdate } from "./xds-resource-type/cluster-resource-type";
import { XdsClient } from "./xds-client";
import { Locality__Output } from "./generated/envoy/config/core/v3/Locality";
import { DropCategory } from "./load-balancer-xds-cluster-impl";
import Endpoint = experimental.Endpoint;
interface WeightedEndpoint {
    endpoint: Endpoint;
    weight: number;
}
interface LocalityEntry {
    locality: Locality__Output;
    weight: number;
    endpoints: WeightedEndpoint[];
}
interface PriorityEntry {
    localities: LocalityEntry[];
}
interface EndpointResource {
    priorities: PriorityEntry[];
    dropCategories: DropCategory[];
}
export interface EndpointConfig {
    type: 'endpoint';
    endpoints?: EndpointResource;
    resolutionNote?: string;
}
export interface AggregateConfig {
    type: 'aggregate';
    leafClusters: string[];
}
export interface ClusterConfig {
    cluster: CdsUpdate;
    children: EndpointConfig | AggregateConfig;
}
export type StatusOr<T> = {
    success: true;
    value: T;
} | {
    success: false;
    error: StatusObject;
};
export interface ClusterResult {
    clusterConfig?: ClusterConfig;
    status?: StatusObject;
}
export interface XdsConfig {
    listener: Listener__Output;
    routeConfig: RouteConfiguration__Output;
    virtualHost: VirtualHost__Output;
    clusters: Map<string, StatusOr<ClusterConfig>>;
}
export interface XdsConfigWatcher {
    onUpdate(xdsConfig: XdsConfig): void;
    onError(context: string, status: StatusObject): void;
    onResourceDoesNotExist(context: string): void;
}
interface HasDomains {
    domains: string[];
}
export declare function findVirtualHostForDomain<T extends HasDomains>(virutalHostList: T[], domain: string): T | null;
export declare class XdsDependencyManager {
    private xdsClient;
    private listenerResourceName;
    private dataPlaneAuthority;
    private watcher;
    private ldsWatcher;
    private rdsWatcher;
    private latestListener;
    private latestRouteConfigName;
    private latestRouteConfiguration;
    private clusterRoots;
    private subscribedClusters;
    private clusterForest;
    constructor(xdsClient: XdsClient, listenerResourceName: string, dataPlaneAuthority: string, watcher: XdsConfigWatcher);
    private trace;
    private handleListenerDoesNotExist;
    private maybeSendUpdate;
    private addCluster;
    addClusterSubscription(clusterName: string): () => void;
    private removeCluster;
    /**
     * Prune any clusters that are not descendents of any root clusters,
     * including subscribed clusters.
     * @returns True if any clusters were pruned, false otherwise
     */
    private pruneOrphanClusters;
    private handleRouteConfig;
    updateResolution(): void;
    destroy(): void;
}
export {};
