"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdsLoadBalancer = exports.ROOT_CLUSTER_KEY = exports.SAN_MATCHER_KEY = exports.IDENTITY_CERT_PROVIDER_KEY = exports.CA_CERT_PROVIDER_KEY = exports.SanMatcher = void 0;
exports.localityToName = localityToName;
exports.setup = setup;
const grpc_js_1 = require("@grpc/grpc-js");
var UnavailablePicker = grpc_js_1.experimental.UnavailablePicker;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var parseLoadBalancingConfig = grpc_js_1.experimental.parseLoadBalancingConfig;
const environment_1 = require("./environment");
const resolver_xds_1 = require("./resolver-xds");
const matcher_1 = require("./matcher");
const net_1 = require("net");
const cidr_1 = require("./cidr");
const TRACER_NAME = 'cds_balancer';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'cds';
class CdsLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                cluster: this.cluster
            }
        };
    }
    constructor(cluster) {
        this.cluster = cluster;
    }
    getCluster() {
        return this.cluster;
    }
    static createFromJson(obj) {
        if (!('cluster' in obj && typeof obj.cluster === 'string')) {
            throw new Error('cds config must have a string field cluster');
        }
        return new CdsLoadBalancingConfig(obj.cluster);
    }
}
function isSupportedSanType(type) {
    return ['DNS', 'URI', 'email', 'IP Address'].includes(type);
}
class DnsExactValueMatcher {
    constructor(targetValue, ignoreCase) {
        this.targetValue = targetValue;
        this.ignoreCase = ignoreCase;
        if (ignoreCase) {
            this.targetValue = this.targetValue.toLowerCase();
        }
    }
    apply(entry) {
        const colonIndex = entry.indexOf(':');
        if (colonIndex < 0) {
            return false;
        }
        const type = entry.substring(0, colonIndex);
        let value = entry.substring(colonIndex + 1);
        if (!isSupportedSanType(type)) {
            return false;
        }
        if (this.ignoreCase) {
            value = value.toLowerCase();
        }
        if (type === 'DNS' && value.startsWith('*.') && this.targetValue.includes('.', 1)) {
            return value.substring(2) === this.targetValue.substring(this.targetValue.indexOf('.') + 1);
        }
        else {
            return value === this.targetValue;
        }
    }
    toString() {
        return 'DnsExact(' + this.targetValue + ', ignore_case=' + this.ignoreCase + ')';
    }
}
function canonicalizeSanEntryValue(type, value) {
    if (type === 'IP Address' && (0, net_1.isIPv6)(value)) {
        return (0, cidr_1.formatIPv6)((0, cidr_1.parseIPv6)(value));
    }
    return value;
}
class SanEntryMatcher {
    constructor(matcherConfig) {
        const ignoreCase = matcherConfig.ignore_case;
        switch (matcherConfig.match_pattern) {
            case 'exact':
                throw new Error('Unexpected exact matcher in SAN entry matcher');
            case 'prefix':
                this.childMatcher = new matcher_1.PrefixValueMatcher(matcherConfig.prefix, ignoreCase);
                break;
            case 'suffix':
                this.childMatcher = new matcher_1.SuffixValueMatcher(matcherConfig.suffix, ignoreCase);
                break;
            case 'safe_regex':
                this.childMatcher = new matcher_1.SafeRegexValueMatcher(matcherConfig.safe_regex.regex);
                break;
            case 'contains':
                this.childMatcher = new matcher_1.ContainsValueMatcher(matcherConfig.contains, ignoreCase);
                break;
            default:
                this.childMatcher = new matcher_1.RejectValueMatcher();
        }
    }
    apply(entry) {
        const colonIndex = entry.indexOf(':');
        if (colonIndex < 0) {
            return false;
        }
        const type = entry.substring(0, colonIndex);
        let value = entry.substring(colonIndex + 1);
        if (!isSupportedSanType(type)) {
            return false;
        }
        value = canonicalizeSanEntryValue(type, value);
        return this.childMatcher.apply(value);
    }
    toString() {
        return this.childMatcher.toString();
    }
}
class SanMatcher {
    constructor(matcherConfigs) {
        this.childMatchers = matcherConfigs.map(config => {
            if (config.match_pattern === 'exact') {
                return new DnsExactValueMatcher(config.exact, config.ignore_case);
            }
            else {
                return new SanEntryMatcher(config);
            }
        });
    }
    apply(value) {
        if (this.childMatchers.length === 0) {
            return true;
        }
        for (const entry of value.split(', ')) {
            for (const matcher of this.childMatchers) {
                const checkResult = matcher.apply(entry);
                if (checkResult) {
                    return true;
                }
            }
        }
        return false;
    }
    toString() {
        return 'SanMatcher(' + this.childMatchers.map(matcher => matcher.toString()).sort().join(', ') + ')';
    }
    equals(other) {
        return this.toString() === other.toString();
    }
}
exports.SanMatcher = SanMatcher;
exports.CA_CERT_PROVIDER_KEY = 'grpc.internal.ca_cert_provider';
exports.IDENTITY_CERT_PROVIDER_KEY = 'grpc.internal.identity_cert_provider';
exports.SAN_MATCHER_KEY = 'grpc.internal.san_matcher';
const RECURSION_DEPTH_LIMIT = 15;
function getLeafClusters(xdsConfig, rootCluster, depth = 0) {
    if (depth > RECURSION_DEPTH_LIMIT) {
        throw new Error(`aggregate cluster graph exceeds max depth of ${RECURSION_DEPTH_LIMIT}`);
    }
    const maybeClusterConfig = xdsConfig.clusters.get(rootCluster);
    if (!maybeClusterConfig) {
        return [];
    }
    if (!maybeClusterConfig.success) {
        return [rootCluster];
    }
    if (maybeClusterConfig.value.children.type === 'aggregate') {
        return [].concat(...maybeClusterConfig.value.children.leafClusters.map(childCluster => getLeafClusters(xdsConfig, childCluster, depth + 1)));
    }
    else {
        return [rootCluster];
    }
}
function localityToName(locality) {
    return `{region=${locality.region},zone=${locality.zone},sub_zone=${locality.sub_zone}}`;
}
exports.ROOT_CLUSTER_KEY = 'grpc.internal.root_cluster';
class CdsLoadBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.latestConfig = null;
        this.localityPriorities = new Map();
        this.priorityNames = [];
        this.nextPriorityChildNumber = 0;
        this.latestSanMatcher = null;
        this.childBalancer = new ChildLoadBalancerHandler(channelControlHelper);
    }
    getNextPriorityName(cluster) {
        return `cluster=${cluster}, child_number=${this.nextPriorityChildNumber++}`;
    }
    updateAddressList(endpointList, lbConfig, options) {
        if (!(lbConfig instanceof CdsLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig, undefined, 2));
            return;
        }
        trace('Received update with config ' + JSON.stringify(lbConfig, undefined, 2));
        const xdsConfig = options[resolver_xds_1.XDS_CONFIG_KEY];
        const clusterName = lbConfig.getCluster();
        const maybeClusterConfig = xdsConfig.clusters.get(clusterName);
        if (!maybeClusterConfig) {
            trace('Received update with no config for cluster ' + clusterName);
            return;
        }
        if (!maybeClusterConfig.success) {
            this.childBalancer.destroy();
            this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker(maybeClusterConfig.error), maybeClusterConfig.error.details);
            return;
        }
        const clusterConfig = maybeClusterConfig.value;
        if (clusterConfig.children.type === 'aggregate') {
            let leafClusters;
            try {
                leafClusters = getLeafClusters(xdsConfig, clusterName);
            }
            catch (e) {
                trace('xDS config parsing failed with error ' + e.message);
                const errorMessage = `xDS config parsing failed with error ${e.message}`;
                this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: errorMessage }), errorMessage);
                return;
            }
            const priorityChildren = {};
            for (const cluster of leafClusters) {
                priorityChildren[cluster] = {
                    config: [{
                            cds: {
                                cluster: cluster
                            }
                        }],
                    ignore_reresolution_requests: false
                };
            }
            const childConfig = {
                priority: {
                    children: priorityChildren,
                    priorities: leafClusters
                }
            };
            let typedChildConfig;
            try {
                typedChildConfig = parseLoadBalancingConfig(childConfig);
            }
            catch (e) {
                trace('LB policy config parsing failed with error ' + e.message);
                const errorMessage = `LB policy config parsing failed with error ${e.message}`;
                this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: errorMessage }), errorMessage);
                return;
            }
            this.childBalancer.updateAddressList(endpointList, typedChildConfig, { ...options, [exports.ROOT_CLUSTER_KEY]: clusterName });
        }
        else {
            if (!clusterConfig.children.endpoints) {
                trace('Received update with no resolved endpoints for cluster ' + clusterName);
                const errorMessage = `Cluster ${clusterName} resolution failed: ${clusterConfig.children.resolutionNote}`;
                this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: errorMessage }), errorMessage);
                return;
            }
            const newPriorityNames = [];
            const newLocalityPriorities = new Map();
            const priorityChildren = {};
            const childEndpointList = [];
            let endpointPickingPolicy;
            if (clusterConfig.cluster.type === 'EDS') {
                endpointPickingPolicy = clusterConfig.cluster.lbPolicyConfig;
                if (environment_1.AGGREGATE_CLUSTER_BACKWARDS_COMPAT) {
                    if (typeof options[exports.ROOT_CLUSTER_KEY] === 'string') {
                        const maybeRootClusterConfig = xdsConfig.clusters.get(options[exports.ROOT_CLUSTER_KEY]);
                        if (maybeRootClusterConfig?.success) {
                            endpointPickingPolicy = maybeRootClusterConfig.value.cluster.lbPolicyConfig;
                        }
                    }
                }
            }
            else {
                endpointPickingPolicy = [{ pick_first: {} }];
            }
            for (const [priority, priorityEntry] of clusterConfig.children.endpoints.priorities.entries()) {
                /**
                 * Highest (smallest number) priority value that any of the localities in
                 * this locality array had a in the previous mapping.
                 */
                let highestOldPriority = Infinity;
                for (const localityObj of priorityEntry.localities) {
                    const oldPriority = this.localityPriorities.get(localityToName(localityObj.locality));
                    if (oldPriority !== undefined &&
                        oldPriority >= priority &&
                        oldPriority < highestOldPriority) {
                        highestOldPriority = oldPriority;
                    }
                }
                let newPriorityName;
                if (highestOldPriority === Infinity) {
                    /* No existing priority at or below the same number as the priority we
                     * are looking at had any of the localities in this priority. So, we
                     * use a new name. */
                    newPriorityName = this.getNextPriorityName(clusterName);
                }
                else {
                    const newName = this.priorityNames[highestOldPriority];
                    if (newPriorityNames.indexOf(newName) < 0) {
                        newPriorityName = newName;
                    }
                    else {
                        newPriorityName = this.getNextPriorityName(clusterName);
                    }
                }
                newPriorityNames[priority] = newPriorityName;
                for (const localityObj of priorityEntry.localities) {
                    for (const weightedEndpoint of localityObj.endpoints) {
                        childEndpointList.push({
                            localityPath: [
                                newPriorityName,
                                localityToName(localityObj.locality),
                            ],
                            locality: localityObj.locality,
                            localityWeight: localityObj.weight,
                            endpointWeight: localityObj.weight * weightedEndpoint.weight,
                            ...weightedEndpoint.endpoint
                        });
                    }
                    newLocalityPriorities.set(localityToName(localityObj.locality), priority);
                }
                priorityChildren[newPriorityName] = {
                    config: endpointPickingPolicy,
                    ignore_reresolution_requests: clusterConfig.cluster.type === 'EDS'
                };
            }
            this.localityPriorities = newLocalityPriorities;
            this.priorityNames = newPriorityNames;
            const xdsClusterImplConfig = {
                xds_cluster_impl: {
                    cluster: clusterName,
                    child_policy: [{
                            priority: {
                                children: priorityChildren,
                                priorities: newPriorityNames
                            }
                        }]
                }
            };
            let childConfig;
            if (environment_1.EXPERIMENTAL_OUTLIER_DETECTION) {
                childConfig = {
                    outlier_detection: {
                        ...clusterConfig.cluster.outlierDetectionUpdate,
                        child_policy: [xdsClusterImplConfig]
                    }
                };
            }
            else {
                childConfig = xdsClusterImplConfig;
            }
            let typedChildConfig;
            try {
                typedChildConfig = parseLoadBalancingConfig(childConfig);
            }
            catch (e) {
                trace('LB policy config parsing failed with error ' + e.message);
                const errorMessage = `LB policy config parsing failed with error ${e.message}`;
                this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: errorMessage }), errorMessage);
                return;
            }
            const childOptions = { ...options };
            if (clusterConfig.cluster.securityUpdate) {
                const securityUpdate = clusterConfig.cluster.securityUpdate;
                const xdsClient = options[resolver_xds_1.XDS_CLIENT_KEY];
                const caCertProvider = xdsClient.getCertificateProvider(securityUpdate.caCertificateProviderInstance);
                if (!caCertProvider) {
                    const errorMessage = `Cluster ${clusterName} configured with CA certificate provider ${securityUpdate.caCertificateProviderInstance} not in bootstrap`;
                    this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: errorMessage }), errorMessage);
                    return;
                }
                if (securityUpdate.identityCertificateProviderInstance) {
                    const identityCertProvider = xdsClient.getCertificateProvider(securityUpdate.identityCertificateProviderInstance);
                    if (!identityCertProvider) {
                        const errorMessage = `Cluster ${clusterName} configured with identity certificate provider ${securityUpdate.identityCertificateProviderInstance} not in bootstrap`;
                        this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ code: grpc_js_1.status.UNAVAILABLE, details: errorMessage }), errorMessage);
                        return;
                    }
                    childOptions[exports.IDENTITY_CERT_PROVIDER_KEY] = identityCertProvider;
                }
                childOptions[exports.CA_CERT_PROVIDER_KEY] = caCertProvider;
                const sanMatcher = new SanMatcher(securityUpdate.subjectAltNameMatchers);
                if (this.latestSanMatcher === null || !this.latestSanMatcher.equals(sanMatcher)) {
                    this.latestSanMatcher = sanMatcher;
                }
                trace('Configured subject alternative name matcher: ' + sanMatcher);
                childOptions[exports.SAN_MATCHER_KEY] = this.latestSanMatcher;
            }
            this.childBalancer.updateAddressList(childEndpointList, typedChildConfig, childOptions);
        }
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        trace('Destroying load balancer rooted at cluster named ' + this.latestConfig?.getCluster());
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.CdsLoadBalancer = CdsLoadBalancer;
function setup() {
    registerLoadBalancerType(TYPE_NAME, CdsLoadBalancer, CdsLoadBalancingConfig);
}
//# sourceMappingURL=load-balancer-cds.js.map