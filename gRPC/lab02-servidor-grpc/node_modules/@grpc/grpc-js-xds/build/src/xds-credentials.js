"use strict";
/*
 * Copyright 2024 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XdsServerCredentials = exports.XdsChannelCredentials = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const load_balancer_cds_1 = require("./load-balancer-cds");
var createCertificateProviderChannelCredentials = grpc_js_1.experimental.createCertificateProviderChannelCredentials;
const TRACER_NAME = 'xds_channel_credentials';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
class XdsChannelCredentials extends grpc_js_1.ChannelCredentials {
    constructor(fallbackCredentials) {
        super();
        this.fallbackCredentials = fallbackCredentials;
    }
    _isSecure() {
        return true;
    }
    _equals(other) {
        return other instanceof XdsChannelCredentials && this.fallbackCredentials === other.fallbackCredentials;
    }
    _createSecureConnector(channelTarget, options, callCredentials) {
        if (options[load_balancer_cds_1.CA_CERT_PROVIDER_KEY]) {
            trace('Using secure credentials');
            const verifyOptions = {};
            if (options[load_balancer_cds_1.SAN_MATCHER_KEY]) {
                const matcher = options[load_balancer_cds_1.SAN_MATCHER_KEY];
                verifyOptions.checkServerIdentity = (hostname, cert) => {
                    if (cert.subjectaltname && matcher.apply(cert.subjectaltname)) {
                        return undefined;
                    }
                    else {
                        trace('Subject alternative name not matched: ' + cert.subjectaltname);
                        return new Error('No matching subject alternative name found in certificate');
                    }
                };
            }
            const certProviderCreds = createCertificateProviderChannelCredentials(options[load_balancer_cds_1.CA_CERT_PROVIDER_KEY], options[load_balancer_cds_1.IDENTITY_CERT_PROVIDER_KEY] ?? null, verifyOptions);
            return certProviderCreds._createSecureConnector(channelTarget, options, callCredentials);
        }
        else {
            trace('Using fallback credentials');
            return this.fallbackCredentials._createSecureConnector(channelTarget, options, callCredentials);
        }
    }
}
exports.XdsChannelCredentials = XdsChannelCredentials;
class XdsServerCredentials extends grpc_js_1.ServerCredentials {
    constructor(fallbackCredentials) {
        super({});
        this.fallbackCredentials = fallbackCredentials;
    }
    getFallbackCredentials() {
        return this.fallbackCredentials;
    }
    _isSecure() {
        return this.fallbackCredentials._isSecure();
    }
    _equals(other) {
        return (other instanceof XdsServerCredentials) && this.fallbackCredentials._equals(other.fallbackCredentials);
    }
}
exports.XdsServerCredentials = XdsServerCredentials;
//# sourceMappingURL=xds-credentials.js.map