"use strict";
/*
 * Copyright 2024 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XdsDependencyManager = void 0;
exports.findVirtualHostForDomain = findVirtualHostForDomain;
const grpc_js_1 = require("@grpc/grpc-js");
const cluster_resource_type_1 = require("./xds-resource-type/cluster-resource-type");
const xds_client_1 = require("./xds-client");
var createResolver = grpc_js_1.experimental.createResolver;
const resources_1 = require("./resources");
const route_config_resource_type_1 = require("./xds-resource-type/route-config-resource-type");
const listener_resource_type_1 = require("./xds-resource-type/listener-resource-type");
const endpoint_resource_type_1 = require("./xds-resource-type/endpoint-resource-type");
const environment_1 = require("./environment");
const TRACER_NAME = 'xds_resolver';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
function isClusterTreeFullyUpdated(tree, roots) {
    const toCheck = [...roots];
    const visited = new Set();
    while (toCheck.length > 0) {
        const next = toCheck.shift();
        if (visited.has(next)) {
            continue;
        }
        visited.add(next);
        if (!tree[next]) {
            return {
                result: false,
                reason: 'Missing expected cluster entry ' + next
            };
        }
        if (!tree[next].latestUpdate) {
            return {
                result: false,
                reason: 'Cluster entry ' + next + ' not updated'
            };
        }
        if (tree[next].latestUpdate.success) {
            if (tree[next].latestUpdate.value.type !== 'AGGREGATE') {
                if (!(tree[next].latestUpdate.value.latestUpdate)) {
                    return {
                        result: false,
                        reason: 'Cluster entry ' + next + ' endpoint not updated'
                    };
                }
            }
        }
        toCheck.push(...tree[next].children);
    }
    return { result: true };
}
// Better match type has smaller value.
var MatchType;
(function (MatchType) {
    MatchType[MatchType["EXACT_MATCH"] = 0] = "EXACT_MATCH";
    MatchType[MatchType["SUFFIX_MATCH"] = 1] = "SUFFIX_MATCH";
    MatchType[MatchType["PREFIX_MATCH"] = 2] = "PREFIX_MATCH";
    MatchType[MatchType["UNIVERSE_MATCH"] = 3] = "UNIVERSE_MATCH";
    MatchType[MatchType["INVALID_MATCH"] = 4] = "INVALID_MATCH";
})(MatchType || (MatchType = {}));
;
function domainPatternMatchType(domainPattern) {
    if (domainPattern.length === 0) {
        return MatchType.INVALID_MATCH;
    }
    if (domainPattern.indexOf('*') < 0) {
        return MatchType.EXACT_MATCH;
    }
    if (domainPattern === '*') {
        return MatchType.UNIVERSE_MATCH;
    }
    if (domainPattern.startsWith('*')) {
        return MatchType.SUFFIX_MATCH;
    }
    if (domainPattern.endsWith('*')) {
        return MatchType.PREFIX_MATCH;
    }
    return MatchType.INVALID_MATCH;
}
function domainMatch(matchType, domainPattern, expectedHostName) {
    switch (matchType) {
        case MatchType.EXACT_MATCH:
            return expectedHostName === domainPattern;
        case MatchType.SUFFIX_MATCH:
            return expectedHostName.endsWith(domainPattern.substring(1));
        case MatchType.PREFIX_MATCH:
            return expectedHostName.startsWith(domainPattern.substring(0, domainPattern.length - 1));
        case MatchType.UNIVERSE_MATCH:
            return true;
        case MatchType.INVALID_MATCH:
            return false;
    }
}
function findVirtualHostForDomain(virutalHostList, domain) {
    let targetVhost = null;
    let bestMatchType = MatchType.INVALID_MATCH;
    let longestMatch = 0;
    for (const virtualHost of virutalHostList) {
        for (const domainPattern of virtualHost.domains) {
            const matchType = domainPatternMatchType(domainPattern);
            // If we already have a match of a better type, skip this one
            if (matchType > bestMatchType) {
                continue;
            }
            // If we already have a longer match of the same type, skip this one
            if (matchType === bestMatchType && domainPattern.length <= longestMatch) {
                continue;
            }
            if (domainMatch(matchType, domainPattern, domain)) {
                targetVhost = virtualHost;
                bestMatchType = matchType;
                longestMatch = domainPattern.length;
            }
            if (bestMatchType === MatchType.EXACT_MATCH) {
                break;
            }
        }
        if (bestMatchType === MatchType.EXACT_MATCH) {
            break;
        }
    }
    return targetVhost;
}
function getEdsResource(edsUpdate) {
    const result = [];
    const dropCategories = [];
    if (edsUpdate.policy) {
        for (const dropOverload of edsUpdate.policy.drop_overloads) {
            if (!dropOverload.drop_percentage) {
                continue;
            }
            let requestsPerMillion;
            switch (dropOverload.drop_percentage.denominator) {
                case 'HUNDRED':
                    requestsPerMillion = dropOverload.drop_percentage.numerator * 10000;
                    break;
                case 'TEN_THOUSAND':
                    requestsPerMillion = dropOverload.drop_percentage.numerator * 100;
                    break;
                case 'MILLION':
                    requestsPerMillion = dropOverload.drop_percentage.numerator;
                    break;
            }
            dropCategories.push({
                category: dropOverload.category,
                requests_per_million: requestsPerMillion
            });
        }
    }
    for (const endpoint of edsUpdate.endpoints) {
        if (!endpoint.load_balancing_weight) {
            continue;
        }
        const endpoints = endpoint.lb_endpoints.filter(lbEndpoint => lbEndpoint.health_status === 'UNKNOWN' || lbEndpoint.health_status === 'HEALTHY').map((lbEndpoint) => {
            /* The validator in the XdsClient class ensures that each endpoint has
             * a socket_address with an IP address and a port_value. */
            let socketAddresses;
            if (environment_1.EXPERIMENTAL_DUALSTACK_ENDPOINTS) {
                socketAddresses = [
                    lbEndpoint.endpoint.address.socket_address,
                    ...lbEndpoint.endpoint.additional_addresses.map(additionalAddress => additionalAddress.address.socket_address)
                ];
            }
            else {
                socketAddresses = [lbEndpoint.endpoint.address.socket_address];
            }
            return {
                endpoint: {
                    addresses: socketAddresses.map(socketAddress => ({
                        host: socketAddress.address,
                        port: socketAddress.port_value
                    }))
                },
                weight: lbEndpoint.load_balancing_weight?.value ?? 1
            };
        });
        if (endpoints.length === 0) {
            continue;
        }
        let priorityEntry;
        if (result[endpoint.priority]) {
            priorityEntry = result[endpoint.priority];
        }
        else {
            priorityEntry = {
                localities: []
            };
            result[endpoint.priority] = priorityEntry;
        }
        priorityEntry.localities.push({
            locality: endpoint.locality,
            endpoints: endpoints,
            weight: endpoint.load_balancing_weight.value
        });
    }
    // Collapse spaces in sparse array
    return {
        priorities: result.filter(priority => priority),
        dropCategories: dropCategories
    };
}
function getDnsResource(endpoints) {
    return {
        priorities: [{
                localities: [{
                        locality: {
                            region: '',
                            zone: '',
                            sub_zone: ''
                        },
                        weight: 1,
                        endpoints: endpoints.map(endpoint => ({ endpoint: endpoint, weight: 1 }))
                    }]
            }],
        dropCategories: []
    };
}
class XdsDependencyManager {
    constructor(xdsClient, listenerResourceName, dataPlaneAuthority, watcher) {
        this.xdsClient = xdsClient;
        this.listenerResourceName = listenerResourceName;
        this.dataPlaneAuthority = dataPlaneAuthority;
        this.watcher = watcher;
        this.latestListener = null;
        this.latestRouteConfigName = null;
        this.latestRouteConfiguration = null;
        this.clusterRoots = [];
        this.subscribedClusters = {};
        this.clusterForest = {};
        this.ldsWatcher = new xds_client_1.Watcher({
            onResourceChanged: (update) => {
                if (!update.api_listener) {
                    this.trace('Received Listener resource not usable on client');
                    this.handleListenerDoesNotExist();
                    return;
                }
                this.latestListener = update;
                const httpConnectionManager = (0, resources_1.decodeSingleResource)(resources_1.HTTP_CONNECTION_MANGER_TYPE_URL, update.api_listener.api_listener.value);
                switch (httpConnectionManager.route_specifier) {
                    case 'rds': {
                        const routeConfigName = httpConnectionManager.rds.route_config_name;
                        if (this.latestRouteConfigName !== routeConfigName) {
                            if (this.latestRouteConfigName !== null) {
                                this.trace('RDS.cancelWatch(' + this.latestRouteConfigName + '): Route config name changed');
                                route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.xdsClient, this.latestRouteConfigName, this.rdsWatcher);
                                this.latestRouteConfiguration = null;
                                this.clusterRoots = [];
                                this.pruneOrphanClusters();
                            }
                            this.trace('RDS.startWatch(' + routeConfigName + '): New route config name');
                            route_config_resource_type_1.RouteConfigurationResourceType.startWatch(this.xdsClient, routeConfigName, this.rdsWatcher);
                            this.latestRouteConfigName = routeConfigName;
                        }
                        break;
                    }
                    case 'route_config':
                        if (this.latestRouteConfigName) {
                            this.trace('RDS.cancelWatch(' + this.latestRouteConfigName + '): Listener switched to embedded route config');
                            route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.xdsClient, this.latestRouteConfigName, this.rdsWatcher);
                            this.latestRouteConfigName = null;
                        }
                        this.handleRouteConfig(httpConnectionManager.route_config);
                        break;
                    default:
                    // This is prevented by the validation rules
                }
            },
            onError: (error) => {
                /* A transient error only needs to bubble up as a failure if we have
                 * not already provided a ServiceConfig for the upper layer to use */
                if (!this.latestListener) {
                    this.trace('Resolution error due to xDS client transient error ' + error.details);
                    this.watcher.onError(`Listener ${listenerResourceName}`, error);
                }
            },
            onResourceDoesNotExist: () => {
                this.trace('Resolution error: LDS resource does not exist');
                this.handleListenerDoesNotExist();
            }
        });
        this.rdsWatcher = new xds_client_1.Watcher({
            onResourceChanged: (update) => {
                this.handleRouteConfig(update);
            },
            onError: (error) => {
                if (!this.latestRouteConfiguration) {
                    this.watcher.onError(`RouteConfiguration ${this.latestRouteConfigName}`, error);
                }
            },
            onResourceDoesNotExist: () => {
                this.watcher.onResourceDoesNotExist(`RouteConfiguration ${this.latestRouteConfigName}`);
                this.clusterRoots = [];
                this.pruneOrphanClusters();
            }
        });
        this.trace('LDS.startWatch(' + listenerResourceName + '): Startup');
        listener_resource_type_1.ListenerResourceType.startWatch(this.xdsClient, listenerResourceName, this.ldsWatcher);
    }
    trace(text) {
        trace('[' + this.listenerResourceName + '] ' + text);
    }
    handleListenerDoesNotExist() {
        if (this.latestRouteConfigName) {
            this.trace('RDS.cancelWatch(' + this.latestRouteConfigName + '): LDS resource does not exist');
            route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.xdsClient, this.latestRouteConfigName, this.rdsWatcher);
            this.latestRouteConfigName = null;
            this.latestRouteConfiguration = null;
            this.clusterRoots = [];
            this.pruneOrphanClusters();
        }
        this.watcher.onResourceDoesNotExist(`Listener ${this.listenerResourceName}`);
    }
    maybeSendUpdate() {
        if (!this.latestListener) {
            this.trace('Not sending update: no Listener update received');
            return;
        }
        if (!this.latestRouteConfiguration) {
            this.trace('Not sending update: no RouteConfiguration update received');
            return;
        }
        const clusterTreeUpdated = isClusterTreeFullyUpdated(this.clusterForest, this.clusterRoots);
        if (!clusterTreeUpdated.result) {
            this.trace('Not sending update: ' + clusterTreeUpdated.reason);
            return;
        }
        const update = {
            listener: this.latestListener,
            routeConfig: this.latestRouteConfiguration,
            virtualHost: findVirtualHostForDomain(this.latestRouteConfiguration.virtual_hosts, this.dataPlaneAuthority),
            clusters: new Map()
        };
        for (const [clusterName, entry] of Object.entries(this.clusterForest)) {
            if (!entry.latestUpdate) {
                this.trace('Not sending update: Cluster entry ' + clusterName + ' not updated (not caught by isClusterTreeFullyUpdated)');
                return;
            }
            if (entry.latestUpdate.success) {
                let clusterChildren;
                if (entry.latestUpdate.value.type === 'AGGREGATE') {
                    clusterChildren = {
                        type: 'aggregate',
                        leafClusters: entry.children
                    };
                }
                else {
                    clusterChildren = {
                        type: 'endpoint',
                        endpoints: entry.latestUpdate.value.latestUpdate ? entry.latestUpdate.value.latestUpdate : undefined,
                        resolutionNote: entry.latestUpdate.value.resolutionNote
                    };
                }
                update.clusters.set(clusterName, {
                    success: true,
                    value: {
                        cluster: entry.latestUpdate.value.cdsUpdate,
                        children: clusterChildren
                    }
                });
            }
            else {
                update.clusters.set(clusterName, {
                    success: false,
                    error: entry.latestUpdate.error
                });
            }
        }
        this.watcher.onUpdate(update);
    }
    addCluster(clusterName) {
        if (clusterName in this.clusterForest) {
            return;
        }
        const entry = {
            watcher: new xds_client_1.Watcher({
                onResourceChanged: (update) => {
                    switch (update.type) {
                        case 'AGGREGATE':
                            if (entry.latestUpdate?.success) {
                                switch (entry.latestUpdate.value.type) {
                                    case 'AGGREGATE':
                                        break;
                                    case 'EDS':
                                        this.trace('EDS.cancelWatch(' + entry.latestUpdate.value.edsServiceName + '): Cluster switched to aggregate');
                                        endpoint_resource_type_1.EndpointResourceType.cancelWatch(this.xdsClient, entry.latestUpdate.value.edsServiceName, entry.latestUpdate.value.watcher);
                                        break;
                                    case 'LOGICAL_DNS':
                                        entry.latestUpdate.value.resolver.destroy();
                                        break;
                                }
                            }
                            entry.children = update.aggregateChildren;
                            entry.latestUpdate = {
                                success: true,
                                value: {
                                    type: 'AGGREGATE',
                                    cdsUpdate: update
                                }
                            };
                            for (const child of update.aggregateChildren) {
                                this.addCluster(child);
                            }
                            this.pruneOrphanClusters();
                            this.maybeSendUpdate();
                            break;
                        case 'EDS':
                            const edsServiceName = update.edsServiceName ?? clusterName;
                            if (entry.latestUpdate?.success) {
                                switch (entry.latestUpdate.value.type) {
                                    case 'AGGREGATE':
                                        entry.children = [];
                                        this.pruneOrphanClusters();
                                        break;
                                    case 'EDS':
                                        // If the names are the same, keep the watch
                                        if (entry.latestUpdate.value.edsServiceName !== edsServiceName) {
                                            this.trace('EDS.cancelWatch(' + entry.latestUpdate.value.edsServiceName + '): EDS service name changed');
                                            endpoint_resource_type_1.EndpointResourceType.cancelWatch(this.xdsClient, entry.latestUpdate.value.edsServiceName, entry.latestUpdate.value.watcher);
                                            this.trace('EDS.startWatch(' + edsServiceName + '): EDS service name changed');
                                            endpoint_resource_type_1.EndpointResourceType.startWatch(this.xdsClient, edsServiceName, entry.latestUpdate.value.watcher);
                                            entry.latestUpdate.value.edsServiceName = edsServiceName;
                                            entry.latestUpdate.value.latestUpdate = undefined;
                                            entry.latestUpdate.value.resolutionNote = undefined;
                                        }
                                        entry.latestUpdate.value.cdsUpdate = update;
                                        this.maybeSendUpdate();
                                        return;
                                    case 'LOGICAL_DNS':
                                        entry.latestUpdate.value.resolver.destroy();
                                        break;
                                }
                            }
                            const edsWatcher = new xds_client_1.Watcher({
                                onResourceChanged: (endpoint) => {
                                    if (entry.latestUpdate?.success && entry.latestUpdate.value.type === 'EDS') {
                                        entry.latestUpdate.value.latestUpdate = getEdsResource(endpoint);
                                        entry.latestUpdate.value.resolutionNote = undefined;
                                        this.maybeSendUpdate();
                                    }
                                },
                                onError: error => {
                                    if (entry.latestUpdate?.success && entry.latestUpdate.value.type === 'EDS') {
                                        if (!entry.latestUpdate.value.latestUpdate) {
                                            entry.latestUpdate.value.resolutionNote = `Control plane error: ${error.details}`;
                                            this.maybeSendUpdate();
                                        }
                                    }
                                },
                                onResourceDoesNotExist: () => {
                                    if (entry.latestUpdate?.success && entry.latestUpdate.value.type === 'EDS') {
                                        entry.latestUpdate.value.resolutionNote = 'Resource does not exist';
                                        entry.latestUpdate.value.latestUpdate = undefined;
                                        this.maybeSendUpdate();
                                    }
                                }
                            });
                            entry.latestUpdate = {
                                success: true,
                                value: {
                                    type: 'EDS',
                                    cdsUpdate: update,
                                    edsServiceName: edsServiceName,
                                    watcher: edsWatcher
                                }
                            };
                            this.trace('EDS.startWatch(' + edsServiceName + '): New EDS service name');
                            endpoint_resource_type_1.EndpointResourceType.startWatch(this.xdsClient, edsServiceName, edsWatcher);
                            this.maybeSendUpdate();
                            break;
                        case 'LOGICAL_DNS': {
                            if (entry.latestUpdate?.success) {
                                switch (entry.latestUpdate.value.type) {
                                    case 'AGGREGATE':
                                        entry.children = [];
                                        this.pruneOrphanClusters();
                                        break;
                                    case 'EDS':
                                        this.trace('EDS.cancelWatch(' + entry.latestUpdate.value.edsServiceName + '): Cluster switched to DNS');
                                        endpoint_resource_type_1.EndpointResourceType.cancelWatch(this.xdsClient, entry.latestUpdate.value.edsServiceName, entry.latestUpdate.value.watcher);
                                        break;
                                    case 'LOGICAL_DNS':
                                        if (entry.latestUpdate.value.dnsHostname === update.dnsHostname) {
                                            entry.latestUpdate.value.cdsUpdate = update;
                                            this.maybeSendUpdate();
                                            return;
                                        }
                                }
                            }
                            this.trace('Creating DNS resolver for hostname ' + update.dnsHostname);
                            const resolver = createResolver({ scheme: 'dns', path: update.dnsHostname }, {
                                onSuccessfulResolution: endpointList => {
                                    if (entry.latestUpdate?.success && entry.latestUpdate.value.type === 'LOGICAL_DNS') {
                                        entry.latestUpdate.value.latestUpdate = getDnsResource(endpointList);
                                        this.maybeSendUpdate();
                                    }
                                },
                                onError: error => {
                                    if (entry.latestUpdate?.success && entry.latestUpdate.value.type === 'LOGICAL_DNS') {
                                        if (!entry.latestUpdate.value.latestUpdate) {
                                            entry.latestUpdate.value.resolutionNote = `DNS resolution error: ${error.details}`;
                                            this.maybeSendUpdate();
                                        }
                                    }
                                }
                            }, { 'grpc.service_config_disable_resolution': 1 });
                            entry.latestUpdate = {
                                success: true,
                                value: {
                                    type: 'LOGICAL_DNS',
                                    cdsUpdate: update,
                                    dnsHostname: update.dnsHostname,
                                    resolver: resolver
                                }
                            };
                            resolver.updateResolution();
                            this.maybeSendUpdate();
                            break;
                        }
                    }
                },
                onError: error => {
                    if (!entry.latestUpdate?.success) {
                        entry.latestUpdate = {
                            success: false,
                            error: error
                        };
                        this.maybeSendUpdate();
                    }
                },
                onResourceDoesNotExist: () => {
                    if (entry.latestUpdate?.success) {
                        switch (entry.latestUpdate.value.type) {
                            case 'EDS':
                                this.trace('EDS.cancelWatch(' + entry.latestUpdate.value.edsServiceName + '): CDS resource does not exist');
                                endpoint_resource_type_1.EndpointResourceType.cancelWatch(this.xdsClient, entry.latestUpdate.value.edsServiceName, entry.latestUpdate.value.watcher);
                                break;
                            case 'LOGICAL_DNS':
                                entry.latestUpdate.value.resolver.destroy();
                                break;
                            default:
                                break;
                        }
                    }
                    entry.latestUpdate = {
                        success: false,
                        error: {
                            code: grpc_js_1.status.UNAVAILABLE,
                            details: `Cluster resource ${clusterName} does not exist`,
                            metadata: new grpc_js_1.Metadata()
                        }
                    };
                    this.maybeSendUpdate();
                }
            }),
            children: []
        };
        this.clusterForest[clusterName] = entry;
        this.trace('CDS.startWatch(' + clusterName + '): Cluster added');
        cluster_resource_type_1.ClusterResourceType.startWatch(this.xdsClient, clusterName, entry.watcher);
    }
    addClusterSubscription(clusterName) {
        this.subscribedClusters[clusterName] = (this.subscribedClusters[clusterName] ?? 0) + 1;
        this.addCluster(clusterName);
        let removeFunctionCalled = false;
        return () => {
            if (!removeFunctionCalled) {
                removeFunctionCalled = true;
                if (clusterName in this.subscribedClusters) {
                    this.subscribedClusters[clusterName] -= 1;
                    if (this.subscribedClusters[clusterName] <= 0) {
                        delete this.subscribedClusters[clusterName];
                        if (this.pruneOrphanClusters()) {
                            this.maybeSendUpdate();
                        }
                    }
                }
            }
        };
    }
    removeCluster(clusterName) {
        if (!(clusterName in this.clusterForest)) {
            return;
        }
        const entry = this.clusterForest[clusterName];
        if (entry.latestUpdate?.success) {
            switch (entry.latestUpdate.value.type) {
                case 'EDS':
                    this.trace('EDS.cancelWatch(' + entry.latestUpdate.value.edsServiceName + '): Cluster ' + clusterName + ' removed');
                    endpoint_resource_type_1.EndpointResourceType.cancelWatch(this.xdsClient, entry.latestUpdate.value.edsServiceName, entry.latestUpdate.value.watcher);
                    break;
                case 'LOGICAL_DNS':
                    entry.latestUpdate.value.resolver.destroy();
                    break;
                default:
                    break;
            }
        }
        this.trace('CDS.cancelWatch(' + clusterName + '): Cluster removed');
        cluster_resource_type_1.ClusterResourceType.cancelWatch(this.xdsClient, clusterName, entry.watcher);
        delete this.clusterForest[clusterName];
    }
    /**
     * Prune any clusters that are not descendents of any root clusters,
     * including subscribed clusters.
     * @returns True if any clusters were pruned, false otherwise
     */
    pruneOrphanClusters() {
        const toCheck = [...this.clusterRoots, ...Object.keys(this.subscribedClusters)];
        const visited = new Set();
        while (toCheck.length > 0) {
            const next = toCheck.shift();
            if (visited.has(next)) {
                continue;
            }
            if (next in this.clusterForest) {
                toCheck.push(...this.clusterForest[next].children);
            }
            visited.add(next);
        }
        let removedAnyClusters = false;
        for (const clusterName of Object.keys(this.clusterForest)) {
            if (!visited.has(clusterName)) {
                removedAnyClusters = true;
                this.removeCluster(clusterName);
            }
        }
        return removedAnyClusters;
    }
    handleRouteConfig(routeConfig) {
        this.latestRouteConfiguration = routeConfig;
        const virtualHost = findVirtualHostForDomain(routeConfig.virtual_hosts, this.dataPlaneAuthority);
        if (!virtualHost) {
            this.clusterRoots = [];
            this.pruneOrphanClusters();
            this.watcher.onError(`RouteConfiguration ${routeConfig.name}`, {
                code: grpc_js_1.status.UNAVAILABLE,
                details: `No matching route found for ${this.dataPlaneAuthority}`,
                metadata: new grpc_js_1.Metadata()
            });
            // Report error
            return;
        }
        const allConfigClusters = new Set();
        for (const route of virtualHost.routes) {
            switch (route.route.cluster_specifier) {
                case 'cluster_header':
                    break;
                case 'cluster':
                    allConfigClusters.add(route.route.cluster);
                    break;
                case 'weighted_clusters':
                    for (const clusterWeight of route.route.weighted_clusters.clusters) {
                        allConfigClusters.add(clusterWeight.name);
                    }
                    break;
                default:
                    // The cluster_specifier can be unset. If so, just ignore it
                    break;
            }
        }
        this.clusterRoots = [...allConfigClusters];
        this.pruneOrphanClusters();
        for (const clusterName of this.clusterRoots) {
            this.addCluster(clusterName);
        }
        this.maybeSendUpdate();
    }
    updateResolution() {
        for (const clusterEntry of Object.values(this.clusterForest)) {
            if (clusterEntry.latestUpdate?.success && clusterEntry.latestUpdate.value.type === 'LOGICAL_DNS') {
                clusterEntry.latestUpdate.value.resolver.updateResolution();
            }
        }
    }
    destroy() {
        this.trace('LDS.cancelWatch(' + this.listenerResourceName + '): destroy');
        listener_resource_type_1.ListenerResourceType.cancelWatch(this.xdsClient, this.listenerResourceName, this.ldsWatcher);
        if (this.latestRouteConfigName) {
            this.trace('RDS.cancelWatch(' + this.latestRouteConfigName + '): destroy');
            route_config_resource_type_1.RouteConfigurationResourceType.cancelWatch(this.xdsClient, this.latestRouteConfigName, this.rdsWatcher);
        }
        this.clusterRoots = [];
        this.subscribedClusters = {};
        this.pruneOrphanClusters();
    }
}
exports.XdsDependencyManager = XdsDependencyManager;
//# sourceMappingURL=xds-dependency-manager.js.map