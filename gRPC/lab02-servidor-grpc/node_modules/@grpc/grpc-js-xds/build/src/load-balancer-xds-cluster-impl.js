"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = setup;
const grpc_js_1 = require("@grpc/grpc-js");
var registerLoadBalancerType = grpc_js_1.experimental.registerLoadBalancerType;
var endpointHasAddress = grpc_js_1.experimental.endpointHasAddress;
var subchannelAddressToString = grpc_js_1.experimental.subchannelAddressToString;
var PickResultType = grpc_js_1.experimental.PickResultType;
var ChildLoadBalancerHandler = grpc_js_1.experimental.ChildLoadBalancerHandler;
var createChildChannelControlHelper = grpc_js_1.experimental.createChildChannelControlHelper;
var selectLbConfigFromList = grpc_js_1.experimental.selectLbConfigFromList;
var BaseSubchannelWrapper = grpc_js_1.experimental.BaseSubchannelWrapper;
var UnavailablePicker = grpc_js_1.experimental.UnavailablePicker;
const resolver_xds_1 = require("./resolver-xds");
const TRACER_NAME = 'xds_cluster_impl';
function trace(text) {
    grpc_js_1.experimental.trace(grpc_js_1.logVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'xds_cluster_impl';
const DEFAULT_MAX_CONCURRENT_REQUESTS = 1024;
class XdsClusterImplLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        const jsonObj = {
            cluster: this.cluster,
            child_policy: [this.childPolicy.toJsonObject()],
        };
        return {
            [TYPE_NAME]: jsonObj
        };
    }
    constructor(cluster, childPolicy) {
        this.cluster = cluster;
        this.childPolicy = childPolicy;
    }
    getCluster() {
        return this.cluster;
    }
    getChildPolicy() {
        return this.childPolicy;
    }
    static createFromJson(obj) {
        if (!('cluster' in obj && typeof obj.cluster === 'string')) {
            throw new Error('xds_cluster_impl config must have a string field cluster');
        }
        if (!('child_policy' in obj && Array.isArray(obj.child_policy))) {
            throw new Error('xds_cluster_impl config must have an array field child_policy');
        }
        const childConfig = selectLbConfigFromList(obj.child_policy);
        if (!childConfig) {
            throw new Error('xds_cluster_impl config child_policy parsing failed');
        }
        return new XdsClusterImplLoadBalancingConfig(obj.cluster, childConfig);
    }
}
class CallCounterMap {
    constructor() {
        this.callCounters = new Map();
    }
    startCall(key) {
        const currentValue = this.callCounters.get(key) ?? 0;
        this.callCounters.set(key, currentValue + 1);
    }
    endCall(key) {
        const currentValue = this.callCounters.get(key) ?? 0;
        if (currentValue - 1 <= 0) {
            this.callCounters.delete(key);
        }
        else {
            this.callCounters.set(key, currentValue - 1);
        }
    }
    getConcurrentRequests(key) {
        return this.callCounters.get(key) ?? 0;
    }
}
const callCounterMap = new CallCounterMap();
class LocalitySubchannelWrapper extends BaseSubchannelWrapper {
    constructor(child, statsObject) {
        super(child);
        this.statsObject = statsObject;
    }
    getStatsObject() {
        return this.statsObject;
    }
    getWrappedSubchannel() {
        return this.child;
    }
}
/**
 * This picker is responsible for implementing the drop configuration, and for
 * recording drop stats and per-locality stats.
 */
class XdsClusterImplPicker {
    constructor(originalPicker, callCounterMapKey, maxConcurrentRequests, dropCategories, clusterDropStats) {
        this.originalPicker = originalPicker;
        this.callCounterMapKey = callCounterMapKey;
        this.maxConcurrentRequests = maxConcurrentRequests;
        this.dropCategories = dropCategories;
        this.clusterDropStats = clusterDropStats;
    }
    checkForMaxConcurrentRequestsDrop() {
        return callCounterMap.getConcurrentRequests(this.callCounterMapKey) >= this.maxConcurrentRequests;
    }
    checkForDrop() {
        for (const dropCategory of this.dropCategories) {
            if (Math.random() * 1000000 < dropCategory.requests_per_million) {
                return dropCategory.category;
            }
        }
        return null;
    }
    pick(pickArgs) {
        let details = null;
        if (this.checkForMaxConcurrentRequestsDrop()) {
            details = 'Call dropped by load balancing policy.';
            this.clusterDropStats?.addUncategorizedCallDropped();
        }
        else {
            const category = this.checkForDrop();
            if (category !== null) {
                details = `Call dropped by load balancing policy. Category: ${category}`;
                this.clusterDropStats?.addCallDropped(category);
            }
        }
        if (details === null) {
            const originalPick = this.originalPicker.pick(pickArgs);
            const pickSubchannel = originalPick.subchannel ? originalPick.subchannel : null;
            return {
                pickResultType: originalPick.pickResultType,
                status: originalPick.status,
                subchannel: pickSubchannel?.getWrappedSubchannel() ?? null,
                onCallStarted: () => {
                    originalPick.onCallStarted?.();
                    pickSubchannel?.getStatsObject()?.addCallStarted();
                    callCounterMap.startCall(this.callCounterMapKey);
                },
                onCallEnded: status => {
                    originalPick.onCallEnded?.(status);
                    pickSubchannel?.getStatsObject()?.addCallFinished(status !== grpc_js_1.status.OK);
                    callCounterMap.endCall(this.callCounterMapKey);
                }
            };
        }
        else {
            return {
                pickResultType: PickResultType.DROP,
                status: {
                    code: grpc_js_1.status.UNAVAILABLE,
                    details: details,
                    metadata: new grpc_js_1.Metadata(),
                },
                subchannel: null,
                onCallEnded: null,
                onCallStarted: null
            };
        }
    }
}
function getCallCounterMapKey(cluster, edsServiceName) {
    return `{${cluster},${edsServiceName ?? ''}}`;
}
class XdsClusterImplBalancer {
    constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.lastestEndpointList = null;
        this.latestConfig = null;
        this.clusterDropStats = null;
        this.xdsClient = null;
        this.latestClusterConfig = null;
        this.childBalancer = new ChildLoadBalancerHandler(createChildChannelControlHelper(channelControlHelper, {
            createSubchannel: (subchannelAddress, subchannelArgs) => {
                if (!this.xdsClient || !this.latestConfig || !this.lastestEndpointList || !this.latestClusterConfig) {
                    throw new Error('xds_cluster_impl: invalid state: createSubchannel called with xdsClient or latestConfig not populated');
                }
                const wrapperChild = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
                let locality = null;
                for (const endpoint of this.lastestEndpointList) {
                    if (endpointHasAddress(endpoint, subchannelAddress)) {
                        locality = endpoint.locality;
                    }
                }
                if (locality === null) {
                    trace('Not reporting load for address ' + subchannelAddressToString(subchannelAddress) + ' because it has unknown locality.');
                    return wrapperChild;
                }
                const lrsServer = this.latestClusterConfig.cluster.lrsLoadReportingServer;
                let statsObj = null;
                if (lrsServer) {
                    statsObj = this.xdsClient.addClusterLocalityStats(lrsServer, this.latestConfig.getCluster(), this.latestClusterConfig.cluster.edsServiceName ?? '', locality);
                }
                return new LocalitySubchannelWrapper(wrapperChild, statsObj);
            },
            updateState: (connectivityState, originalPicker, errorMessage) => {
                if (this.latestConfig === null || this.latestClusterConfig === null || this.latestClusterConfig.children.type === 'aggregate' || !this.latestClusterConfig.children.endpoints) {
                    channelControlHelper.updateState(connectivityState, originalPicker, errorMessage);
                }
                else {
                    const picker = new XdsClusterImplPicker(originalPicker, getCallCounterMapKey(this.latestConfig.getCluster(), this.latestClusterConfig.cluster.edsServiceName), this.latestClusterConfig.cluster.maxConcurrentRequests ?? DEFAULT_MAX_CONCURRENT_REQUESTS, this.latestClusterConfig.children.endpoints.dropCategories, this.clusterDropStats);
                    channelControlHelper.updateState(connectivityState, picker, errorMessage);
                }
            }
        }));
    }
    updateAddressList(endpointList, lbConfig, options) {
        if (!(lbConfig instanceof XdsClusterImplLoadBalancingConfig)) {
            trace('Discarding address list update with unrecognized config ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
            return;
        }
        trace('Received update with config: ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
        const xdsConfig = options[resolver_xds_1.XDS_CONFIG_KEY];
        const maybeClusterConfig = xdsConfig.clusters.get(lbConfig.getCluster());
        if (!maybeClusterConfig) {
            trace('Received update with no config for cluster ' + lbConfig.getCluster());
            return;
        }
        if (!maybeClusterConfig.success) {
            this.latestClusterConfig = null;
            this.childBalancer.destroy();
            this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker(maybeClusterConfig.error), maybeClusterConfig.error.details);
            return;
        }
        const clusterConfig = maybeClusterConfig.value;
        if (clusterConfig.children.type === 'aggregate') {
            trace('Received update for aggregate cluster ' + lbConfig.getCluster());
            return;
        }
        if (!clusterConfig.children.endpoints) {
            this.childBalancer.destroy();
            this.channelControlHelper.updateState(grpc_js_1.connectivityState.TRANSIENT_FAILURE, new UnavailablePicker({ details: clusterConfig.children.resolutionNote }), clusterConfig.children.resolutionNote ?? null);
        }
        this.lastestEndpointList = endpointList;
        this.latestConfig = lbConfig;
        this.latestClusterConfig = clusterConfig;
        this.xdsClient = options[resolver_xds_1.XDS_CLIENT_KEY];
        if (clusterConfig.cluster.lrsLoadReportingServer) {
            this.clusterDropStats = this.xdsClient.addClusterDropStats(clusterConfig.cluster.lrsLoadReportingServer, lbConfig.getCluster(), clusterConfig.cluster.edsServiceName ?? '');
        }
        this.childBalancer.updateAddressList(endpointList, lbConfig.getChildPolicy(), options);
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
function setup() {
    registerLoadBalancerType(TYPE_NAME, XdsClusterImplBalancer, XdsClusterImplLoadBalancingConfig);
}
//# sourceMappingURL=load-balancer-xds-cluster-impl.js.map